title: 作用域和闭包
category: 你不懂JS
tag: [JavaScript,翻译]
date: 2016-09-30
toc: true
layout: post

---

个人翻译《你不懂JS》系列第二本，由书名就能看出来这一本的主要内容是什么。这本书先简单介绍了编译原理，然后再开始讲解作用域，作用域的诸多细节都有涉及到，最后花了很长篇幅来介绍闭包。不过有些地方我结合我自己的学习过程，觉得他讲的还是不太好，我不自量力的稍微做了点补充。本书原文的语言风格比较轻佻，很多夸张的描述和感叹，本人的英语水平实在是不太好，无法准确的还原，有些比喻可能看起来会比较尴尬……还请见谅。另外，本书前言以及鸣谢和第一本一模一样，本书以及系列之后的书都不再重复，如果想看的话，请看第一本。
<!--more-->

# 序言

能为Kyle Simpson的《你不知道的JS》系列第一本书《作用域和闭包》作序，我感到非常荣幸。我劝你最好买上这么一本书来看看，无论你有没有经验，它毫无疑问都值得你去读一读。
当我还是小孩子的时候，我最喜欢的事情就是把东西拆了，然后再把它组装回去。像是什么老旧的移动电话啊，HI-FI音响啊，以及任何我能拿到的东西。那时候我还很小，并不懂如何真正使用这些设备，但是每当我把它们拆开之后，我会马上问我自己，我能搞懂它是如何工作的吗。
我还记得有一次我在摆弄一个旧收音机的电路板，上面有个又长又奇怪的管子，那个管子是用铜线圈包裹起来的。我不明白它工作的目的是什么，但我马上就进入了研究模式。它有什么用？为什么它在收音机里面？为什么它和电路板上的其他东西看起来不太一样？为什么它会被铜线包裹起来？如果我把铜线去掉会发生什么？现在我知道了，它是个环形天线，铜线包裹着的是铁氧体棒，这是在晶体管收音机中使用的东西。
你曾经沉迷于搞清楚每一个“为什么”中吗？大多数小孩都是这样的，事实上，这可能是我在小孩子身上最喜欢的特质——他们的求知欲。
不幸的是，现在的我被认为是“专业的”，而且我每天都生活在创造之中。当我还年轻的时候，我热爱着那天我分解物品时想出的各种办法。当然，我现在做的绝大部分事情都是使用JavaScript来完成的，和当年的铁氧体棒不一样……但是它们在某种意义上来说也挺相似的，对吧。但是，尽管过去我曾经热爱创造事物，但现在的我更希望弄明白事物的本质。确实，我经常想出解决问题或者是修复错误的最好方法，但是我却很少去质疑工具本身。
而这就是为什么我看到Kyle的这个《你不懂JS》系列书籍时非常激动的原因。因为他是对的，我不懂JS，我日复一日长年累月地使用着JavaScript，但我真的理解它吗？答案是否定的。的确，我对它很了解，我也经常阅读规范，但我仍然不懂，我所懂得的并没有达到我这6年间想要达到的水平。
《作用域和闭包》，对于这个系列来说是个辉煌的开始，它对于我这样人来说是非常棒的（希望你也是如此），它不会讲解JavaScript，而且就算你从未使用过它，这本书也能让你意识到它内部的工作机制。
它在现在这个完美的时间中现身，ES6终于稳定了下来，跨浏览器也能顺利的实施了，如果你还没有学到最近的新特性（像是`let`和`const`），这本书也将会详细的介绍它们。
所以，我希望你能喜欢这本书，但同样你能和Kyle一样，批判性的思考为什么语言的细节为什么是这样，这种思维方式将会慢慢的影响你的心态以及你的日常工作。不仅仅是使用天线，更要弄明白它的工作原理。

# 第一章：什么是作用域？

几乎所有的编程语言最根本的范式就是将值存储到变量中，而后检索或者修改这些值。事实上，把值储存到变量中以及从变量中拿出值，这样的能力给予了程序“状态”。
如果没有这个概念，一个程序也能执行一些任务，但是它们的能力极为有限，也不怎么有趣。
但是，假如我们把“变量”引入程序中，我们将先要解决一个非常有趣的问题：这些变量“生存”在哪里？换种说法，变量们都存储在哪里？还有最为重要的，当我们需要这个变量的时候，我们的程序该如何找到这个变量？
这些问题我们都需要好好定义一番。将变量储存在某个地方的规则，以及随后寻找这些变量的规则，我们把这一套规则称作：作用域。
那么，问题又来了，这些作用域的规则又是在哪里以及如何设置呢？

## 编译原理

这也许是很明显但也是比较意想不到的，总之，这取决于一个语言在变量层面的交互方式。尽管JavaScript在一般意义上来说是“动态”或者“解释性”语言，但是实际上它也是会编译的。很多传统的编译型语言都是事先编译好，然后将编译的结果运行在各种系统中，但是JavaScript并不是这样的。
但是，尽管如此，相比于很多传统编译器，虽然JavaScript引擎执行了很多和它们相同的步骤，但这些比它们要复杂的多。
在传统的编译语言过程中，源代码块，你的程序，在执行前通常都会经历三个步骤，这个过程就是“编译”：

1. **标记化/词法分析（Tokenizing/Lexing）：**将字符串元素进行（对语言而言）有意义的分割，分割出来的块就被称为**标记（tokens）**，举个例子，这样一段程序`var a = 2;`，这个程序将会被分割成这些的标记：`var`、`a`、`=`、`2`、`;`。空白是不是标记，这取决于它是否有意义。
2. **语法分析（Parsing）：**将标记们组成的数据流（数组）转换为嵌套元素的树结构，这棵树总体上就代表了程序的句法结构，它被称作“AST”（抽象语法树 **A**bstract **S**yntax **T**ree）。
   对于`var a = 2`而言，树将会从`变量声明(VariableDeclaration)`的根节点开始，然后紧跟着的是`标志符(Identifier)`（它的值是`a`）和`赋值表达式(AssignmentExpression)`，他们两个是根节点的子节点。然后赋值表达式也有一个子节点，它被称做`数值节点(NumericLiteral)`（它的值是`2`）。
3. **代码生成（Code-Generation）：**生成AST之后，就需要把它转换为可执行的代码。在这个部分，它和是什么语言以及针对什么平台都会有很大的不同。
   为了不让我们陷入细节中，我们现在就简单说说，对于描述了`var a = 2;`的AST，它转变成了一组机器码，这些机器码将会*创建*一个被称做`a`的变量（包括储存值的内存等等），然后把储存的值给予`a`。

   
<p class="note">
标记化和词法分析的区别是很微妙很学术的，但是它们的核心区别就在于，标记被定义的时候是否有对应的状态。简单的来说，如果分词器是调用状态解析规则来分析变量`a`到底是个独立的标记或者是某个标记的一部分，这就是词法分析。
引擎如何管理这些系统资源的细节是个更加深入的话题，所以在这里，我们只需要知道它能够创建和储存变量的值就足够了。
</p>

JavaScript的引擎远比上面提到的传统编译器的三个步骤要复杂得多，例如，在语法分析和代码生成这里，肯定有诸如折叠冗余元素等等这样的代码优化的步骤。
所以，我在这里也仅仅是画个粗线条，但是你应该明白我为什么要讲解这些细节，因为即便是在较高的层次^注^中，它们仍然是相关联的。
<p class="translator">
这里的层次，指的是相对于编译层，应用层，这样的分类而言。
</p>

JavaScript引擎并没有大量的时间（对于其他的语言的编译器而言）去做代码优化，因为JavaScript的编译并不是像其他语言那样在构建阶段之前完成。
对于JavaScript而言，在绝大多数情况下，编译仅仅花费了代码执行前的几个微秒。为了确保最快的性能，JS引擎使用了各种各样的技巧（比如JITs，它有着懒惰编译，甚至是热重新编译等等技术），这些细节远远超出了我们在这里讨论的“作用域”的内容。
话说回来，简而言之，任何JavaScript片段在执行之前都会被编译。所以对于程序片段`var a = 2;`首先会先编译它，然后立刻准备好执行。

## 理解作用域

我们学习作用域的方法就是在谈话中接近它们的思考方式。不过，对话的主角们都是谁呢？

### 主角们

我们去拜访一下处理程序`var a = 2;`的工作人员吧，听听它们都说了什么：

1. 引擎：负责JavaScript程序的启动、编译、执行的工作。
2. 编译器：引擎的一个朋友，负责处理所有*肮脏*的工作——语法分析和代码生成（见上一节）。
3. 作用域：引擎的另一个朋友，收集和维护所有的声明标识符（变量），并将它们整合成查找表。然后在当前代码执行时，以一系列严格的规则来访问它们。


为了能让你*完全理解*JavaScript的工作方式，你需要开始像引擎（以及它的朋友们）那样去思考，问它们会问的问题，然后回答这些问题。

### 来回

当你看到程序`var a = 2;`的时候，你最有可能想到的是，这是一个语句。但是这并不是我们的新朋友引擎的想法。事实上，引擎看到了两个不同的语句，一个在编译器执行编译，一个在引擎中执行。
让我们来分析一下引擎和它的朋友们是如何看待这个程序`var a = 2`的。
首先，编译器将会把这段程序按照词法规则拆分成各种标记，然后构建语法树，之后编译器就会生成代码。
对于生成代码这一步，我们有一个看起来比较合理的猜想：“给变量分配内存，并将它标记，然后把值2分配给那个变量”。但是，这个猜想并不准确。
编译器其实做了这么些步骤：
1. 当它碰到`var a`的时候，编译器将会询问当前作用域，变量`a`是否存在。如果在特定的作用域范围中，变量`a`已经存在，那么编译器将会忽略并删除这个声明，否则编译器将会在刚才那个作用域范围中声明这个变量。
2. 编译器生成的代码将会被引擎马上执行。对于`a = 2`这个赋值语句，引擎运行它的时候，将会首先询问作用域，在作用于范围中，这个变量是允许访问的吗。如果可以，那么引擎将会使用这个变量，否则编译器将会在别的地方寻找这个变量（参考下面作用域嵌套的相关章节）。


假如引擎最终找到了变量`a`，那么它将把值`2`赋值给它，要是没有找到，引擎就会举起它的双手，然后糊你一脸错误！

**总结：**上面的赋值语句包含了两个行为：首先，编译器声明了变量（如果在当前作用域中它还没有被声明），然后当代码执行的时候，引擎将会在作用域中寻找这个变量，并将它赋值，当然前提是引擎找到了这个变量。

### 编译器所言

我们需要一点编译器的术语来进行进一步的理解过程。
当引擎运行了在第二步中编译器生成的代码的时候，它将会在相关作用域中查询变量`a`是否已经声明，但是，引擎进行查询的这个行为也是有着不同的类型，而这也将会影响查询的结果。
在我们这个情况，引擎查询变量`a`的行为类型被称做“LHS”，而别的类型被称做“RHS”。
我敢打赌你能够猜得到“L”和“R”的意思。这两个缩写的全称是“左边（Left-hand Side）”和“右边（Right-hand Side）”。
左边右边？是什么东西的左边右边？是**赋值运算符**的左边和右边。
换句话说，LHS查询将会在变量出现在赋值运算符左边的时候执行，而RHS将会在变量出现在赋值运算符的右边的时候执行。
现在，我们能定义的更准确点。RHS查询是无法区分的，因为对于我们而言，我们只是想要简单的查询这些变量的值，但是与之相对的，LHS查询将会尝试找到变量自身的容器，以便于可以将它赋值。所以，RHS其实并不意味着“赋值运算符的右边”，更准确的来说，它只是意味着“不是左边”。
又或者我们可以稍微转换下思路，你也能够认为“RHS”是指“检索他/她的来源（值）”，这意味着RHS的意义就是“拿到……的值”。
让我们更深入一点。
当我说：
```javascript
console.log( a );
```

变量`a`的引用是RHS引用，因为这里并没有给`a`赋值。相对的，我们查询了`a`的值，所以我们能把值传给`console.log(..)`。
对比下面的：

```javascript
a = 2
```

在这里的变量`a`的引用就是LHS的了，因为我们其实并不关心它实际的值是什么，我们仅仅是想找到这个变量，然后运行`= 2`这个赋值运算罢了。

<p class="note">
LHS和RHS的意思是“赋值的左/右边”，但这并不是说它确实真正意味着是“赋值运算符`=`的左/右边”。赋值运算中还有好几种其他的查询方式，所以在这里将它们的概念理解为“谁是赋值的目标（LHS）”和“谁是赋值的来源（RHS）”，这样要更好点。
</p>

看看下面的程序，LHS和RHS分别是哪个：

```javascript
function foo(a) {
    console.log( a ); // 2
}

foo( 2 );
```

在最后一行调用函数`foo(..)`是对变量`foo`的RHS引用，话句话说就是这样：“去查询`foo`的值，然后把它给我！”然后，`(..)`意味着`foo`的值应该被运行起来，所以它最好是个函数！
上面的代码片段中有个非常微妙但重要的赋值运算。**你发现了吗？**
你可能没有注意到，在这个代码片段中隐含了`a = 2`。它是在`2`作为参数传输到`foo(..)`函数中的时候发生的，此时`2`就被赋值给了参数`a`。参数`a`的赋值，执行的是LHS引用。
对于变量`a`，还有个RHS引用。那就是它的值将会传输到`console.log(..)`中。`console.log(..)`也是需要引用然后执行的。它先使用RHS查询了`console`对象，然后在属性中查询，看是否有一个名为`log`的方法。
最后，我们可以把这个步骤进行概念化的描述，就是使用了LHS或者RHS查询到了值`2`（在这里是对变量`a`使用了RHS查询），然后把它传输到了`log(..)`中。对于内部原生实现的`log(..)`，我们也能假设它也定义有参数，我们将会把LHS引用查询到的值，就是之前赋值给`a`的`2`，把它传输给第一个参数（也许它叫`arg1`）。

<p class="note">
你可能会尝试这把函数声明`function foo(a) {...`当作一个普通的变量声明和赋值，然后将它概念化，比如`var foo`然后`foo = function(a){...`。如果这样做了，它将会将这个函数声明认为是个LHS查询。
</p>

然而，在编译器同时处理声明和代码生成时的值分配时，这两者也有些微妙且重要的区别。例如当引擎执行代码的时候，就没有必要把函数值“赋值”给`foo`。因此，在这里把函数声明当作是LHS查询的赋值运算并不合适。

### 引擎和作用域的对话

```javascript
function foo(a) {
    console.log( a ); // 2
}

foo( 2 );
```

让我们把它们处理这段代码片段的过程想象成一段对话吧，它们的对话有点像是这样：

> 引擎：嘿，作用域。我想要`foo`的RHS引用，你之前有听它没？
> 作用域：收到，我看看。编译器刚刚才声明了它，它是个函数，给你。
> 引擎：太棒了，感谢！好了， 我现在就要执行`foo`了。
> 引擎：作用域啊，我还想要`a`的LHS引用，你之前有听过它吗？
> 作用域：收到。编译器在刚才声明了它作为`foo`的形参，给你。
> 引擎：一直以来感谢了，作用域。现在，是时候把`2`赋值给`a`了。
> 引擎：作用域啊，我又要打扰你了。我需要`console`的RHS引用。
> 作用域：没问题的，引擎，这是我的工作。好了，我找到`console`了，它是个内建对象，给你。
> 引擎：太完美了。找找`log(..)`属性。找到了，它是个函数。
> 引擎：呦，作用域。你再帮我找找`a`的RHS引用，我觉得我还记得它，但是我想再检查一遍。
> 作用域：你说得对，小心驶得万年船。找到了，是同一个家伙，它没有变，给你。
> 引擎：好了，把`a`的值`2`给传进`log(..)`。
> ……

### 小测试

这里是为了检查下你的理解，你可以梳理一下引擎和作用域的“对话”：

```javascript
function foo(a) {
    var b = a;
    return a + b;
}

var c = foo( 2 );
```

1. 辨认出所有的LHS查询（这里有3个）。
2. 辨认出所有的RHS查询（这里有4个）。

<p class="note">
最后的章节概述中有答案。
</p>

## 嵌套作用域
我们说作用域是使用标识符名称来查询变量的一套规则，但是通常而言我们都需要考虑一个以上的作用域。
就像一个块或者是函数嵌套在另一个块或者函数里面一样，作用域也可以嵌套在另一个作用域里面。所以，假如变量不能在最近的作用域中找到，引擎就会去外部包含的作用域查询，直到找到这个变量或者说到了最外层的作用域（全局作用域）。
比如：

```javascript
function foo(a) {
    console.log( a + b );
}

var b = 2;

foo( 2 ); // 4
```

对于变量`b`，并没有在函数`foo`内部找到，但是它能够在包围着这个函数作用域的作用域（在这里，是全局作用域）中找到它。
所以，我们再来回顾一下我无意中偷听到的引擎和作用域的对话：

> 引擎：嘿！`foo`的作用域，之前你听过`b`没？把它的RHS引用给我。
> 作用域：没有，我之前从未听过它。
> 引擎：嘿！`foo` 外面的那个作用域哟！啊，你是全局作用域啊，那太棒了。你有听过`b`吗？把它的RHS引用给我。

![作用域的高楼比喻](/img/scope-closures/01.png)
这个建筑就代表了我们嵌套作用域的规则集。大楼的一楼代表着你当前正在执行的作用域，而建筑物的顶层则代表着全局作用域。
你可以在你当前的楼层使用RHS或者是LHS引用，要是你没有找到，乘坐电梯到上面一个楼层继续寻找，以此类推。一旦你到了顶层（全局作用域），你要么找到了你要的变量要么没有，但是无论如何你都必须要停止了。

## 错误

在什么情况下LHS和RHS查询会发生错误呢？
当我们在相关作用域中查找的变量还没有声明的时候，而且RHS和LHS这两种类型查找在环境中行为还有所不同。
例如：

```javascript
function foo(a) {
    console.log( a + b );
    b = a;
}

foo( 2 );
```

第一次对变量`b`进行RHS查询的时候，没有找到。它将会变成“未声明”的变量，因为它没有在作用域中找到。
假如说RHS查询失败了，就是说在相关作用域中没有找到该变量，这时候引擎会抛出`ReferenceError`错误。值得注意的是这个错误类型，名为`ReferenceError`。
与此相反，如果引擎正在执行LHS查找，直到顶层（全局作用域）也没能找到变量，而且程序没有运行在"严格模式"下，然后全局作用域将会用你搜索的标识符的名字，在全局作用域中创建一个新的变量，然后把这个变量返回给引擎。

> 在这之前并没有这个变量，但是我能给你创建一个新的。

在ES5中添加的“严格模式”，相比普通/宽松/懒惰模式有很多不同的行为。其中一个就是不允许隐式创建全局变量。在这种情况下，LHS查找就不能从全局找到并返回那个变量，所以引擎在这里和RHS查找的情况类似，也将会抛出`ReferenceError`错误。
现在，假如变量被RHS查找找到了，但是你想用它的值做些什么是不可能的^注^。比如尝试用非函数的值去执行函数，又或者说在`null`或者是`undefined`中引用属性，如果你这么做了，引擎将会抛出另外一种错误，名为`TypeError`。

<p class="translator">
非严格模式下，省略了`var`的变量引用将会隐式创建全局变量。而当变量仅仅是声明而没有赋值的时候，它的值将会是`undefined`。
</p>

`ReferenceError`和作用域解析失败相关，而`TypeError`则意味着作用域解析成功了，但是却试图对结果采用了违规/不可能的行为。

## 综述

作用域是变量（标识符）在哪里以及如何能被查询到的规则集。LHS（Left-hand Side）引用会在变量赋值中使用，RHS（Right-hand Side）会在检索变量值的时候使用。
LHS引用是赋值运算的运算结果，`=`运算符以及给函数参数传递参数值都能引发作用域相关的赋值操作。
JavaScript引擎在执行代码前的首次编译中，它将像是`var a = 2;`这样的语句切割成了两个独立的部分：
1. 首先`var a`将会在作用域中声明变量。这个过程是在代码运行之前完成。
2. 之后`a = 2`将会查找变量（LHS引用）然后给它赋值。

LHS和RHS引用一开始都将会在当前执行的作用域中查询变量，如果需要的话（也就是说，它们没有在当前作用域中找到需要的变量）它们会沿着嵌套的作用域向上查询，直到到达全局作用域（楼顶）然后停止，对于要查找的变量，要么找到了要么没有找到。
如果RHS没有实现，将会引发`ReferenceError`错误，LHS没有实现，将会隐式创建全局变量（没在严格模式下），或者抛出`ReferenceError`错误（在严格模式下）。

### 测验答案

```javascript
function foo(a) {
    var b = a;
    return a + b;
}

var c = foo( 2 );
```

1. 辨认出所有的LHS查询（这里有3个）
`c = ..`，`a = 2`（隐式参数赋值）以及`b = ..`
2. 辨认出所有的RHS查询（这里有4个）
`foo(2..`，`= 2;`，`a + ..`以及`.. + b`

<p class="note">
关于严格模式，请参考[MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Strict_mode)。
</p>

# 第二章：词法作用域

在第一章我们定义了“作用域”，就是引擎在当前亦或是嵌套的作用域中通过标识符的名字来查找变量的一套规则集。
对于作用域的工作原理，现在有两种比较优秀的模型。其中之一是迄今为止最为常见的，也是被绝大多数编程语言所使用的，它被称做“词法作用域（Lexical Scope）”，我们一会儿将会对它做深入的讲解。另外一种模型现在仍然被少部分语言所使用（比如bash脚本，还有perl中的一些模式等等），它被称做“动态作用域（Dynamic Scope）”。
JavaScript采用的是词法作用域模型，动态作用域在附录A有个简单的介绍，这里仅仅是把它作为词法作用域的简单对照。

## 词法分析之时
正如我们在第一章讨论的那样，标准语言编译器运行的时候，它的第一个传统阶段被称为词法分析（又名标记化）。你应该还记得，词法分析阶段会检查源代码的字符串，然后将它们按照语义分配给标记们，最后这些标记就是状态分析的结果。
这个概念就是我们理解词法作用域是什么的基础，也是标识符这个名称的由来。
词法作用域就是定义词法时候的作用域，这个定义有点像是循环定义。换句话来说，词法作用域是在当你写下变量和代码块的时候就已经决定了，因此它在词法分析器处理你的代码时（基本上）是固定不变的。

<p class="note">
之后我们将会看到一些欺骗词法作用域的方法，它能够修改已经经过词法分析器处理过的内容，但是这些做法已经完全被抛弃。事实上公认的最佳实践是，将词法作用域看作是仅仅依靠词法的，因此在本质上完全是编写时决定的。
</p>

让我们来看看下面这个代码块：

```javascript
function foo(a) {

    var b = a * 2;

    function bar(c) {
        console.log( a, b, c );
    }

    bar(b * 3);
}

foo( 2 ); // 2 4 12
```

在上面这个代码片段中有三个嵌套的作用域，下面这张图对于理解它们之间像是气泡一样的嵌套关系有点用处：

![嵌套作用域](/img/scope-closures/02.png)

**气泡1** 涵盖了全局作用域，并且在它内部有一个标识符：`foo`。
**气泡2** 包括了`foo`作用域，它有3个标识符：`a`、`bar`和`b`。
**气泡3** 包括了`bar`作用域，它只含有一个标识符：`c`。

作用域气泡定义在哪里以及谁嵌套在谁内部，这些是在它被写下的时候就决定好了。在下一章我们将会讨论不同的作用域范围，但是现在，我们先假设每一个函数将会创建一个新的作用域气泡。
气泡`bar`是被完全包含在气泡`foo`中，因为（也仅仅因为）我们就是在气泡`foo`内部定义的函数`bar`。
请注意，这些气泡的嵌套都是严格的嵌套关系，它们并不是可以跨越边界的韦恩图。换句话说，没有气泡可以同时存在于两个外部气泡内，就像没有函数能同时有两个父函数一样。

### 查找

这些气泡作用域的结构和相对位置充分说明了引擎需要在所有地方查找一个标识符。
在上面那个代码片段中，引擎执行`console.log(..)`语句的时候，就需要寻找`a`，`b`和`c`三个变量的引用。搜索会从最里面的作用域气泡开始，也就是函数`bar(..)`的作用域。引擎在这里没有发现变量`a`，于是它会向上一个层级，来到了外边嵌套着的离当前作用域最近的作用域气泡，即`foo(..)`的作用域。在这里发现了`a`，然后就提取出`a`的值拿去使用。对于变量`b`是一样的，但是对于`c`，我们在`bar(..)`内部就找到它了。
**当引擎首次匹配到了，搜索就会停止。**在嵌套的作用域中允许有相同名字的标识符，这种现象被称作“遮蔽(shadowing)”（内部的标识符将会将外部的标识符“遮蔽”住）。无论是不是被遮蔽了，作用域的查找总是从最里面的作用域开始执行的，然后一直向上直到到达最外层或者是第一次匹配到标识符，然后就会停止。
<p class="note">
全局变量会自动变成`global`对象（在浏览器中是`window`）的属性。所以不直接使用词法名称，而是引用`global`对象的属性来间接的使用它。
</p>

```javascript
window.a
```

这个技术可以直接访问到那些被遮蔽的全局变量。但是，这个技术并不能访问被遮蔽的非全局变量。
无论函数在那里或是如何被调用，它的词法作用域也仅仅是定义在声明它的地方。
词法作用域的查找进程只会处理第一级的标识符，就像`a`、`b`和`c`。假如你在代码片段中引用了`foo.bar.baz`，词法作用域将会搜索`foo`标识符，但是一旦找到了这个变量，将会按照对象属性查找规则来分别搜索`bar`和`baz`属性。

## 作弊之词
假如词法作用域只会在函数声明的时候被定义，这是由代码作者决定的，那么怎么可能会有实时的“修改”（或者说“欺骗”）词法作用域的方法呢？
JavaScript有这样两个机制，它们在代码中的各种错误实践，让广大社区的开发者们皱起了眉头。但是，在反驳这些错误实践的论据中，人们又往往忘记了最重要的一点：**欺骗词法作用域将会导致性能的降低。**
在我解释它们的性能问题之前，先让我们看看这两种机制的工作原理。

### `eval`

在JavaScript中，`eval(..)`函数接受一个字符串作为参数，并且假设字符串的内容实际上已经在该处作为了程序的代码。换句话说，你能够以编程的方式在你的代码中，再生成以及运行生成的代码，当然肯定要这些代码在你编码的时候就已经存在。
为了评估`eval(..)`函数，必须要很清楚`eval(..)`是如何允许你通过欺骗和伪装来达到修改词法作用域环境的。
当代码运行了`eval(..)`之后，引擎将不会再“知道”或者说“关心”前面代码的动态解释，这就导致词法作用域的环境被修改了。引擎将会简单的执行其词法作用域的查找步骤，因为它一直都是这样的。
考虑下面的代码：

```javascript
function foo(str, a) {
    eval( str ); // cheating!
    console.log( a, b );
}

var b = 2;

foo( "var b = 3;", 1 ); // 1, 3
```

字符串`"var b = 3;"`在`eval(..)`调用的时候被处理成为你所代表的代码。而这段代码在这里声明了一个新的变量`b`，它修改了`foo(..)`已经存在的的词法作用域。事实上，正如上面提到的，这段代码实际上在`foo(..)`内部创建了变量`b`，然后这个变量`b`声明之后遮蔽了外部（全局）作用域的`b`。
当调用`console.log(..)`的时候，引擎发现了在`boo(..)`作用域内的变量`a`和`b`，而且并没有发现外部的`b`。因此，我们最终打印出来了`1,3`而不是平常那样的`1,2`。

<p class="note">
在这个例子中，为了简单起见，作为“代码”的字符串是一个固定的字面量。但是，根据你程序的逻辑，它也可以很容易的以编程的方式来进行动态的添加。`eval(..)`通常被用于执行动态创建代码，然而直接从字符串字面量创建静态代码相比于直接书写代码而言没有任何优势。
</p>

默认情况下，如果被`eval(..)`执行的字符串代码中，包含了一个或者多个声明（变量或者函数），这个`eval(..)`中的操作就会修改当前的词法作用域。从技术上来讲，通过使用各种技巧（超出了我们这里讨论的话题），`eval(..)`也能够被“间接”的调用。在这种情况下，它能够取代全局作用域执行的上下文，从而达到修改它的目的。在这两种情况下，`eval(..)`都能够实时的修改编码时的词法作用域。

<p class="note">
`eval(..)`当在严格模式下被调用的时候，`eval(..)`内部的变量声明将不会修改相关联的作用域。
</p>

```javascript
function foo(str) {
   "use strict";
   eval( str );
   console.log( a ); // ReferenceError: a is not defined
}

foo( "var a = 2" );
```

JavaScript中还有其他语句和`eval(..)`的效果类似。`setTimeout(..)`和`setInterval(..)`，它们相应的第一个参数可以是字符串，而这个字符串就能够被转换为动态生成的函数代码，这是一种古老的历史遗产问题的行为，而且这种代码也被大家长期抨击和反对，所以，绝不要这么做！
`The Function(..)`函数的构造函数也有着相似的功能，它将接受一个字符串最为最后一个参数，然后将会根据这个字符串动态生成函数（第一个参数将会是这个新函数的名字）。这个函数构造法比起`eval(..)`要安全得多，但是你仍然应该在代码中避免这么做。
这些动态生成代码的用法都是非常罕见的，因为性能下降带来的损失远超过它们带来的价值。

### `with`

在JavaScript中能够欺骗词法作用域，并且让大家皱眉头的另一个特性，那就是`with`关键字（现在已经不推荐使用！）。有很多种方法来解释`with`，但是我将会从它如何互动并且影响词法作用域的角度来解释。
`with`通常的解释是用一个速记符号来代替对象的多属性引用，而不再需要每次都重复引用需要的对象。
例如：

```javascript
var obj = {
    a: 1,
    b: 2,
    c: 3
};

// more "tedious" to repeat "obj"
obj.a = 2;
obj.b = 3;
obj.c = 4;

// "easier" short-hand
with (obj) {
    a = 3;
    b = 4;
    c = 5;
}
```

然而，这个行为除了可以将对象属性访问简单化，还有很多副作用，例如：

```javascript
function foo(obj) {
    with (obj) {
        a = 2;
    }
}

var o1 = {
    a: 3
};

var o2 = {
    b: 3
};

foo( o1 );
console.log( o1.a ); // 2

foo( o2 );
console.log( o2.a ); // undefined
console.log( a ); // 2 -- Oops, leaked global!
```

在这个例子中创建了`o1`和`o2`两个对象，一个有属性`a`，另一个没有。在`foo(..)`函数中把对象`obj`的引用当作是参数，然后对其调用了`with(obj) {..}`，在`with`的代码块中，我们似乎是按照普通的词法引用方式去引用了变量`a`，事实上这是个LHS引用（参考第一章），我们随即将值`2`赋给了它。
然后我们将`o1`传输进了`foo(..)`函数中，赋值语句`a = 2`将会找到属性`o1.a`然后把值`2`赋给它，这将会反映在随后的的语句`console.log(o1.a)`中。然而，当我们把`o2`传输进函数中时，因为这个对象并没有属性`a`，这个属性也并没有被创建，所以最后`o2.a`将会保持`undefined`。
但是，这时候我们将会发现一个奇怪的副作用，那就是有一个全局变量通过`a = 2`语句被创建了。为什么会这样？
在`with`语句中，作为参数的对象通常都拥有一个或者多个属性，并且**将会把对象看作是完全独立的词法作用域**，因此这个对象的属性才能在那个“作用域”中被看作是词法定义上的标识符。

<p class="note">
即使是`with`能够把对象当作是词法作用域，但是在其代码块中使用`var`声明的时候，新的变量并不会存在于当前代码块中，而是在包围着它的函数作用域中。
</p>

如果在代码字符串中拥有一个或者多个声明，`eval(..)`函数就能够修改已经存在的词法作用域。而`with`语句实际上根据你传输进去的对象，创建了一个全新的词法作用域。
我们换个角度来理解，当我们将`o1`传输进`with`语句的时候，“作用域”就被声明了，在那个“作用域”之中还有一个“标识符”对应着`o1.a`属性。但是当我们用`o2`创建“作用域”的时候，它里面并没有这样的“标识符”，所以才会发生普通规则的LHS查找（参考第一章）。
不管是`o2`的“作用域”，还是`foo(..)`的作用域，甚至是全局作用域，总得找到个标识符`a`啊，所以当执行`a = 2`的时候，它将会自动在全局创建（假设我们在非严格模式）。
这种思想上的转变似乎有点奇怪，在运行的时候，对象和它的属性成为了“作用域”和“标识符”，但是这已经是我能给大家看到的最为清晰的解释了。

<p class="note">
在代码中使用`eval(..)`和`with`是个坏主意，事实上这俩在严格模式下是被限制了的。`with`被完全彻底的禁用，`eval(..)`仅仅被保留了核心功能，各种间接或者不安全的使用都是被禁止的。
</p>

### 性能

`eval(..)`和`with`都在运行的时候实时的修改或者是创建了新的作用域，通过这种方式来欺骗了编码之时就定义好的词法作用域。
这时候，你问道，这没什么大不了的吧？假如说这提供了更加先进的功能以及更加灵活的编码方式，难道它们不是优秀的特性吗？答案是**否定的**。
JavaScript的引擎有很多性能优化都是在编译阶段完成的。它们很大程度上归结于静态代码分析，通过词法分析，可以预先确定所有的变量和函数声明都在哪里，因此在执行代码的时候处理标识符的问题就话费更少的时间。
但是当引擎在代码中发现了`eval(..)`和`with`语句时，它基本上必须要假设其所有的标识符地点认知可能都是无效的，因为它不能在词法分析阶段确切的知道这两个语句的确切行为，无论是修改词法作用域亦或是根据对象创建新的词法作用域，但是它不知道你将会传输什么样的代码到`eval(..)`中，或者是传输什么样的对象到`with`中。
悲观的来说，对于`eval(..)`和`with`而言，大多数优化对于它们俩是毫无意义的。所以它们俩没有执行任何优化。
只要你的代码中使用了`eval(..)`或者是`with`，那几乎可以肯定能你的代码运行起来将会很慢。无论引擎有多聪明的试图限制这些悲观的假设和副作用，**没有任何优化，代码将会运行的更慢，这一事实是无论如何都无法绕过的。**

## 综述

词法作用域是在编码的时候就已经决定好的，由函数声明划定好的作用域。编译的词法分析阶段就能知道所有标识符在哪里以及如何声明的，从而预测它们在执行过程中将如何被查找。
在JavaScript中有两个机制能够“欺骗”词法作用域：`eval(..)`和`with`。前者通过一个带有一个或者多个声明的“代码”字符串作为参数，能够修改已经存在的词法作用域（在运行时）。后者实际上创建了一整个新的词法作用域（同样也是在运行时），而它则是把一个对象引用当作是“作用域”，并且把对象的属性们当作是作用域的标识符。
这些机制有着很严重的缺点，那就是它们违背了引擎执行有关作用域查找编译时候的优化，因为引擎必须悲观的认为这种优化对它们是无效的。如果代码中使用了这两种特性，那么代码将会无可避免的变慢。所以，请不要使用他们。

# 第三章：函数级与块级作用域

正如我们在第二章所探讨的那样，作用域是由一系列的“气泡”组成的，这些气泡内部充满了各种被声明了的标识符（变量，函数）。这些气泡也能相互嵌套，当然了，嵌套关系是在编码的时候就定义好了的。
但是，究竟是什么创建了新的气泡？仅仅只是函数吗？有没有别的结构能在JavaScript中创建作用域气泡呢？

## 从函数而来的作用域

这个问题最常见的回答就是，JavaScript有函数级的作用域。也就是说，每当你声明了一个函数，都将会创建一个它自己的气泡。但是，再没有其他的结构能创建它们自己的作用域气泡了。正如我们接下来将会看到的，这其实并不完全正确。
但是首先，让我们来看看函数作用域以及它的影响。
考虑以下的代码：
```javascript
function foo(a) {
    var b = 2;

    // some code

    function bar() {
        // ...
    }

    // more code

    var c = 3;
}
```

在上面的代码片段中，`foo(..)`函数的作用域气泡中包括了`a`，`b`，`c`以及`bar`这么几个标识符。在这个作用域中，无论作用域中的声明出现在哪里，声明的变量或者是函数总是属于整个作用域气泡。我们将在下一章探讨这个话题。
`bar(..)`有它自己的作用域气泡，所以全局作用域中就只有一个标识符：`foo`。
因为`a`，`b`，`c`以及`bar`都是属于`foo(..)`的作用域，所以它们并不能在`foo(..)`外部被访问到。也就是说，下面的代码将会得到`ReferenceError `错误，因为这些标识符在全局作用域中并不存在：

```javascript
bar(); // fails

console.log( a, b, c ); // all 3 fail
```

然而，所有的这些标识符（`a`，`b`，`c`以及`bar`）都能够在`foo(..)`内部被访问到，而且也能够在`bar(..)`中访问到（假设在`bar(..)`中并没有能够将这些标识符遮蔽的声明）。
变量属于整个函数，并且能够在整个函数中反复使用（实际上还包括嵌套的作用域），函数作用域鼓励这样的设计思路。这种设计方式可以说是非常有用的，而且能充分利用JavaScript变量的“动态”特性，让变量拥有不同类型的值。
在另一方面，如果你不小心采取预防措施，跨作用域的变量可能会导致意想不到的陷阱。

## 隐藏于普通作用域

传统的构思函数的方法是，你声明一个函数，然后往其中添加代码。但是逆向的思考方式也同样很强大很有用：取出你已经书写的代码的任意片段，然后声明一个函数将这些代码包裹起来，这实际上就起了“隐藏”代码的效果。
这在结果上就是创建了围绕着代码的新的作用域气泡，这也就意味着在该代码中的所有声明（变量和函数）都将会绑定在这个新的函数作用域中，而不是先前外围的这个作用域。换句话说，你就能通过这个新的函数将这些变量和函数都“隐藏起来”。
为什么“隐藏”变量和函数是个有用的技术？
有很多原因促使了基于作用域的这一隐藏声明的技术。这主要还是因为软件设计的“[最小权限原则](https://en.wikipedia.org/wiki/Principle_of_least_privilege)”，它有时也被称作“最小权限（Least Authority）”或者是“最小曝光（Least Exposure）”。该原则指出，在设计的软件中，比如API模块/对象，你对外应该只公开最低限度的接口，除此之外全部“隐藏”起来。
这一原则同样也延伸到了对于作用域保持变量和函数的选择上。假如说所有的变量和函数都是全局变量，作用域们不管如何嵌套都能够随意访问它们。但是这就违反了“最……”的原则，除开必须要对外暴露的变量和函数，其余的最好保持它的私有特性，编码过程中并不鼓励去访问这些私有属性的变量。
例如：

```javascript
function doSomething(a) {
    b = a + doSomethingElse( a * 2 );

    console.log( b * 3 );
}

function doSomethingElse(a) {
    return a - 1;
}

var b;

doSomething( 2 ); // 15
```

在这个片段中，变量`b`和`doSomethingElse(..)`函数都像是`doSomething(..)`做它自己的工作时候的“私有”的细节（译者注：这里的意思主要是说变量`b`和函数`doSomethingElse(..)`在这里仅仅就只有`doSomething(..)`函数调用了它们，别的地方没有用到。）。让封闭作用域“访问”变量`b`和`doSomethingElse(..)`不仅是没有必要的，也可能是“危险”的，因为它们可能会有意或者无意的被意想不到的方式使用，而且这也可能违反`doSomething(..)`的前置条件假设。
更为“合理”的设计应该是将这些私有的细节包含在`doSomething(..)`函数内部：

```javascript
function doSomething(a) {
    function doSomethingElse(a) {
        return a - 1;
    }

    var b;

    b = a + doSomethingElse( a * 2 );

    console.log( b * 3 );
}

doSomething( 2 ); // 15
```

现在，`b`和`doSomethingElse(..)`不会收到外界影响，外界也无法访问它们了，它们现在只会受到`doSomething(..)`控制。它的功能和最终结果不会受到外部的任何影响，并且在设计中保持私有细节的私有性，这通常就被认为是很好的软件。

### 避免冲突

在作用域内部“隐藏”变量和函数还有另外一个好处，那就是能够避免两个有着相同名字，但是使用目的又有所不同的标识符之间的意外冲突，这样的冲突经常导致变量的值被意外改写。
比如：

```javascript
function foo() {
    function bar(a) {
        i = 3; // changing the `i` in the enclosing scope's for-loop
        console.log( a + i );
    }

    for (var i=0; i<10; i++) {
        bar( i * 2 ); // oops, infinite loop ahead!
    }
}

foo();
```

`i = 3`这个是在`bar(..)`内部进行的赋值，不过`i`却是在`for`循环中声明的。在这种情况下，它将会导致无限循环，因为`i`被固定为`3`了，而它永远都是`< 10`的。
无论你选择什么样的标识符名称，在`bar(..)`中都需要声明一个局部变量来使用。`var i = 3`将会解决这个问题（对于声明的`i`，这里就是之前提到的“变量遮蔽”）。另外补充一下，选择使用另外一个，像是`var j = 3;`这样完全不同的标识符名称也是可以的，但是你的软件设计可能会自然的要求你使用相同的标识符名称，所以在这种情况下使用作用域来“隐藏”内部声明，是你最好的也是唯一的选择。

#### 全局“命名空间”

这里有个在全局作用域中发生变量冲突的典型例子，那就是多个库加载到你的程序的时候，如果它们没有好好隐藏自己内部/私有函数和变量，那就可能会很容易的相互冲突。
这样的库通常会创建一个单一的变量声明，一般是一个对象，这个变量在全局作用域中具有足够唯一性的名字。这个对象就会被当作是这个库的“命名空间”，其中所有特定的对外暴露的功能都会被当作是该对象（命名空间）的属性，而不是顶级词法作用域中的标识符。
例如：

```javascript
var MyReallyCoolLibrary = {
    awesome: "stuff",
    doSomething: function() {
        // ...
    },
    doAnotherThing: function() {
        // ...
    }
};
```

#### 模块管理

为了避免冲突，现在还有另外一个选择，那就是使用各种依赖管理的更加现代的“模块”的方式。使用这些工具，没有库通过任何标识符添加到全局范围，但是相反它们会通过运用依赖管理器的各种机制，然后用它们自身的标识符显式的导入到特定的作用域中。
应该注意到，这些工具并不是具有不受作用域规则约束，这样“魔法”般的力量。它们只是简单的运用了作用域的规则，没有标识符被注入到任何公共作用域，并保持它们的私有性，以防止任何作用域的意外冲突。
因此，如果你选择这样做的话，你可以防御性地编码，并在实际上不使用依赖管理器的情况下，取得与使用它们相同的结果。更多信息你可以参考第五章的模块模式。

## 作为作用域的函数

我们能看到，我们可以使用函数将任何代码片段包裹起来，这样能够将代码片段中的函数和变量的声明都“隐藏”起来，让函数内部的作用域和外部作用域相互隔绝开来互不影响。
比如：

```javascript
var a = 2;

function foo() { // <-- insert this

    var a = 3;
    console.log( a ); // 3

} // <-- and this
foo(); // <-- and this

console.log( a ); // 2
```

虽然这种技术“作品”并不一定十分理想，但是我们在这里仅仅是由它引入一些问题。首先我们声明了一个具名函数`foo()`，这意味着标识符名称`foo`它自己“污染”了当前的封闭作用域（在这里是全局作用域）。为了执行它内部的代码，我们还必须按它的名字显式调用它（`foo()`）。
如果函数并不需要一个名称（或者说该名称不会污染封闭作用域），而且该函数将能被自动的执行，这应该就是更为理想的情况了。
幸运的是，JavaScript提供了解决这两个问题的解决方案。

```javascript
var a = 2;

(function foo(){ // <-- insert this

    var a = 3;
    console.log( a ); // 3

})(); // <-- and this

console.log( a ); // 2
```

让我们来看看这里发生了什么。
首先请注意封装函数的语句，由`(function...`开始而不是`function...`，这看起来可能只是个小细节，但是这实际上是个重大的变化，这样做能够让解释器把这个看作是函数表达式，而不是标准的函数声明。（译者注：这里需要看补充。）
<p class="note">
区分声明和表达式最简单的方法就是单词`function`在语句中所处的位置（不是一行，而是一个独立的语句）。假如`function`是在语句的最开头，那么这就是函数声明，否则它就是函数表达式。
</p>

我们能注意到，函数声明和函数表达式最大的区别，和它的名字在哪里绑定成标识符的有点关系。
比较两个片段，在第一个片段中，`foo`是绑定在当前封闭作用于中的，我们想要调用它可以直接直接使用`foo()`。在第二个片段中，`foo`并没有绑定在当前封闭作用域中，而是仅仅绑定在了它自身的函数内部。
换句话说，`(function foo(){...})`作为一个表达式就意味着标识符`foo`只绑定在了`...`所表示的内部，而不是外面的这个作用域。将`foo`隐藏在它自己内部就意味着它并不会污染当前封闭作用域。

### 匿名与具名

你最熟悉的函数表达式可能就是它作为回调函数的参数了，例如：

```javascript
setTimeout( function(){
    console.log("I waited 1 second!");
}, 1000 );
```

这被称做“匿名函数表达式”，因为`function()...`它没有作为名字的标识符。函数表达式可以是匿名的，但是函数声明并不能省去名字——那将是非法的JS语法。
匿名函数表达式是快速和容易输入的，许多库和工具都倾向于鼓励这个代码的惯用风格，然而也几个要点必须考虑：

1. 匿名函数在堆栈跟踪里面没有用于显示的名字，这将会让调试变得更加困难。
2. 没有名字，假如函数需要引用自身，比如递归等，那就必须要使用`arguments.callee`来引用自身，但是我们并不推荐在实际中使用`arguments.callee`。需要引用子自身的另一个例子是当事件处理程序函数想要在触发之后想要解除自身的绑定。
3. 匿名函数省略的名字，能增强程序的可读性，让程序变得更容易理解^注^。一个描述性的名字有助于代码的自我记录。

<p class="translator">
作者为啥喜欢说的这么绕……这里就是说函数名字可以用来描述函数自己，有利于读代码的人更好的理解，所以匿名函数不好。不要理解反了……
</p>

**内联函数表达式**是强大而且有用的——匿名函数和具名函数的问题并不会影响它。给你的函数表达式提供一个名字，它能够有效的解决这些并不是切实缺点的隐患。最好的做法就是，始终给函数表达式命名：

```javascript
setTimeout( function timeoutHandler(){ // <-- Look, I have a name!
    console.log( "I waited 1 second!" );
}, 1000 );
```

### 立即执行函数表达式

```javascript
var a = 2;

(function foo(){

    var a = 3;
    console.log( a ); // 3

})();

console.log( a ); // 2
```

现在，我们通过在函数周围包装上一对`()`，让它变成了函数表达式，想要让这个函数执行那也很简单，在它最后添加上另外的`()`就行了，就像这样`(function foo(){...})()`。第一个封闭的`()`将函数变成表达式，然后第二个`()`将执行这个函数。
这种模式是非常普遍的，几年前社区就商定了它的术语：**IIFE**，立即执行函数表达式（**I**mmediately **I**nvoked **F**unction **E**xpression）。
当然，IIFE并不需要名字——IIFE最常见的用法就是使用匿名函数表达式。虽然的确不太常见，但是命名一个IIFE比起匿名函数而言有着前面说过的诸多优点，所以我建议你在实践中这么做。

```javascript
var a = 2;

(function IIFE(){

    var a = 3;
    console.log( a ); // 3

})();

console.log( a ); // 2
```

比起传统的IIFE，形式上略有变化。有些人更喜欢这样：`(function(){...}())`。仔细一看，确实有点细微的差别。在第一种形式中，函数表达式被整个包裹在`()`中，然后调用它的一对`()`是在它之后放在它外面的。而第二种形式，调用它的一对`()`也别包裹在了第一对`()`之中。
这两种形式在功能上是完全相同的^注^，这纯粹只是**风格喜好问题**。

<p class="translator">
更深入的探讨，请阅读这篇文章：[函数声明与函数表达式](/archives/2016/02/function-dec-exp-ano/)。
</p>

事实上，还有另外一种IIFE的变体形式也使用的相当普遍，其实这也只是函数调用，不过是还传递了参数而已。
比如：

```javascript
var a = 2;

(function IIFE( global ){

    var a = 3;
    console.log( a ); // 3
    console.log( global.a ); // 2

})( window );

console.log( a ); // 2
```

我们把`window`这个对象引用传递了进去，然后我们将这个参数命名为`global`。这让大家有个明确的全局和非全局引用。当然，你可以在封闭作用域中传递任何你想传递的东西，你也能够给参数命名任何你想要的名字，这也仅仅是风格问题。
这种模式还解决了另一个问题，那就是默认的`undefined`标识符可能会被意外的覆盖^注^，从而导致意外的结果。通过给`undefined`参数命名，但并不传递任何值给参数，我们就能保证在这个代码块中，`undefined`标识符就是事实上的“未定义值”：

```javascript
undefined = true; // setting a land-mine for other code! avoid!

(function IIFE( undefined ){

    var a;
    if (a === undefined) {
        console.log( "Undefined is safe here!" );
    }

})();
```

<p class="translator">
另外补充一点，`undefined`可以被覆盖，但是`null`并不会。它们之间为什么会有这样的区别，请看这篇文章：[undefined与null的区别](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html)。
</p>

这里仍然是IIFE的另外一种变形，函数执行的时候将另一个函数作为参数传递进去。这种模式通常是在UMD（通用模块定义 **U**niversal **M**odule **D**efinition）中使用。可能有人觉得这不太好理解，我在这里稍微再啰嗦几句：

```javascript
var a = 2;

(function IIFE( def ){
    def( window );
})(function def( global ){

    var a = 3;
    console.log( a ); // 3
    console.log( global.a ); // 2

});
```

`def`函数表达式是在片段的下半段中定义的，然后把它作为一个参数（也叫做`def`）传递进了上半段代码中被称做`IIFE`的函数中。最后，参数`def`（函数）被调用了，同时还把`window`作为参数传递了进去，参数名字叫`global`。

## 作为作用域的块

函数是最为普遍的作用域单位，同时在JS中最为广泛的设计方法是循环，其他单位的作用域单位是可能的，并且如果有其他单位的作用域必然能让我们写出更好更清洁的代码。
在JavaScript之外的很多语言都是支持块级作用域的，而且有相当多的开发者是从这些语言转来的，所以他们大多数可能都有这样的思维定势，只有那些以JavaScript为主要工作的开发者们可能在发现这个概念的时候觉得惊讶。
但是，即便你从来没有写过一行关于块级作用域的代码，但是你绝对非常熟悉这个在JavaScript中极其常见的片段：

```javascript
for (var i=0; i<10; i++) {
    console.log( i );
}
```

我们直接在循环顶部声明了变量`i`，我们之所以这么做的最大原因就是，我们想要只在该`for`循环中使用这个变量`i`，并且将会忽略在外部作用域（函数或者全局）中拥有同名标识符的变量。
所谓块级作用域就是这么一回事儿。声明变量尽可能的接近，越接近使用它们的地方越好。另外一个例子：

```javascript
var foo = true;

if (foo) {
    var bar = foo * 2;
    bar = something( bar );
    console.log( bar );
}
```

我们只在`if`语句的上下文中使用`bar`变量，这让我们有种我们在`if`块中声明了变量的感觉。但是当我们使用`var`来声明变量的时候，这些变量实际上是不相关的，因为它们将永远属于当前封闭作用域中，这个片段实际上是“假”的块级作用域。之所以这么写其实只是文本风格上的原因，当然还得小心不要在这个作用域的别的地方不小心使用了变量`bar`。
块级作用域是扩展之前“最小权限原则”的工具，它能够让我们从函数中隐藏信息进化到从代码块中隐藏信息。
看看下面这个`for`循环的例子：

```javascript
for (var i=0; i<10; i++) {
    console.log( i );
}
```

为什么我们想要使用这个`for`循环，就要（或者说不得不）用变量`i`来污染整个函数作用域？
而且更重要的是，开发者们可能更喜欢检查它们自身，以防止使用变量的时候偏离了它本来的目的。比如，如果你尝试在是一个错误的地方使用未知变量，从而发生了错误。对于变量`i`而言，假设我在函数的别的地方访问它导致了错误，解释器也将会保证`i`在这个`for`循环的块级作用域（如果有的话）中的有效性。这将会有助于确保变量没有在混乱且难以维持的方式下的复用。
然而，现实就是如此悲伤，JavaScript没有这么方便的块级作用域。
嘛，直到你前进了那一步为止。

### `with`

我们在第二章学习了`with`，虽然它是个让我们皱眉头的结构，但是它也是块级作用域（的形式）的例子，那个被他由对象创建而来的作用域，它将只会存在于`with`语句中，并不属于外部这个封闭作用域。

### `try/catch`

这是个鲜为人知的事实，JavaScript在ES3的时候就能做到这些了。在`try/catch`的`catch`块中声明的变量将会只属于`catch`块的块级作用域。
例如：

```javascript
try {
    undefined(); // illegal operation to force an exception!
}
catch (err) {
    console.log( err ); // works!
}

console.log( err ); // ReferenceError: `err` not found
```

正如你所看到的那样，`err`仅仅只会存在于`catch`块中，当你在别的地方引用它的时候，解释器将会抛出一个错误。

<p class="note">
虽然这种行为在几乎所有的标准JS环境（也许除了旧IE）都是如此，但是当你在同一个作用域中，有两个或者是更多的`catch`块，并且在它们之中分别声明了相同标识符名字的错误变量，这时仍然有很多代码质量检查器会报错。这实际上并不是被重新定义了，自变量仍然是被安全隔离开了的，但是这些代码质量检查器仍然觉得这种行为是危险的，这很烦人。
</p>

为了避免这些不必要的警告，有时候开发者们会将他们的`catch`变量命名为`err1`，`err2`等等。还有些开发者将会更直接的关掉代码质量检查器的重复变量检查功能。
`catch`块级作用域的形式看起来很像是没什么用的，但是你应该看看附录B，你会发现这玩意儿其实非常有用。

### `let`

到目前为止，我们已经看到了JavaScript中很多具有块级作用域的行为，但是这些行为都很奇怪很小众。如果那就是我们拥有的全部，过了这么多年，块级作用域也不会给JavaScript开发者提供这么多帮助。
幸运的是，ES6改变了一切，它引入了一个新的关键字`let`，它是`var`的变种，是另一种声明变量的方式。
`let`关键字声明的变量将会存在于当前的代码块（通常是一对`{...}`）中。换句话说，`let`将会隐式的劫持块级作用域作为它声明的变量的作用域。

```javascript
var foo = true;

if (foo) {
    let bar = foo * 2;
    bar = something( bar );
    console.log( bar );
}

console.log( bar ); // ReferenceError
```

`let`将会把变量隐式的添加到当前存在的块之中。然而，不同的块也具有不同的行为，甚至于有些块其实并不能提供块级作用域，所以如果你不密切关注这些问题，你很可能会被这些问题弄晕。
为块级作用域创建明确的块能够解决这些问题，能更加明显的看出变量到底是附加在哪个块中。通常情况下，显式的创建代码块比隐式的要更好点，这不仅仅是因为显式的方式更容易实现，更因为这样做更自然的符合块级作用域在其他语言中的实现：

```javascript
var foo = true;

if (foo) {
    { // <-- explicit block
        let bar = foo * 2;
        bar = something( bar );
        console.log( bar );
    }
}

console.log( bar ); // ReferenceError
```

通过一对`{..}`我们就能给`let`创建任意的块，在任何语句中这样的行为都是合法的。 在上面这种情况下，我们在`if`语句之中创建了显式的语句块，这可能更容易作为一个整体代码块在代码重构移动之后，而不影响封闭`if`语句的位置和语义。

<p class="note">
对于另一种表达显式块级作用域的方法，请参考附录B。
</p>

在第四章，我们将会针对声明提升展开讲解。所谓声明提升，就是说被声明的某个变量是属于整个作用域的。
然而，使用`let`声明的变量将不会在当前块级作用域中提升，在当前代码块中，在这个声明语句之前，这个声明将会是“不存在”的。

```javascript
{
   console.log( bar ); // ReferenceError!
   let bar = 2;
}
```

#### 垃圾收集

块级作用域非常有用的另一个原因涉及到闭包和垃圾回收。我们将在这里简单的说明它们，不过闭包储存的细节将会在第五章详细说明。
考虑下面的代码：

```javascript
function process(data) {
    // do something interesting
}

var someReallyBigData = { .. };

process( someReallyBigData );

var btn = document.getElementById( "my_button" );

btn.addEventListener( "click", function click(evt){
    console.log("button clicked");
}, /*capturingPhase=*/false );
```

函数`click`在处理单击句柄回调的时候完全不需要变量`someReallyBigData`。这就意味着，从理论上讲，在`process(..)`运行之后`someReallyBigData`就可以被当作是垃圾被收集起来了。然而，JS引擎很可能（尽管依赖于实现方式）会继续保持这个这附近的数据结构，因为函数`click`在整个作用域中有一个闭包。
块级作用域就能够解决这个问题，使得引擎能清楚的知道，它并不需要保持`someReallyBigData`：

```javascript
function process(data) {
    // do something interesting
}

// anything declared inside this block can go away after!
{
    let someReallyBigData = { .. };

    process( someReallyBigData );
}

var btn = document.getElementById( "my_button" );

btn.addEventListener( "click", function click(evt){
    console.log("button clicked");
}, /*capturingPhase=*/false );
```

显式的创建代码块，在那之中声明需要绑定的本地变量，这是一种非常有效的方式，你可以将它添加到你的代码工具箱中。

#### `let`循环

正如我们之前讨论的那样，`for`循环是`let`的一种非常典型的应用。

```javascript
for (let i=0; i<10; i++) {
    console.log( i );
}

console.log( i ); // ReferenceError
```

`let`在`for`循环头之中，不仅仅会将`i`绑定在循环体中，并且每次循环迭代都将会把`i`**重新绑定**，确保在上一次循环迭代结束的时候进行重新赋值。
这里是每次迭代绑定行为的另一个例子：

```javascript
{
    let j;
    for (j=0; j<10; j++) {
        let i = j; // re-bound for each iteration!
        console.log( i );
    }
}
```

为什么每次迭代都需要重新绑定，原因非常有趣，我们将会在第五章讨论闭包的时候详细讲解。
`let`声明将会附加到任意代码块中，而不是当前封闭函数作用域（或者是全局作用域）。不过这里有一个陷阱必须要注意，在代码块中的变量将会遮蔽函数作用域中使用`var`声明的变量，所以当你用`let`替换`var`重构代码的时候必须要注意。
思考下面的代码：

```javascript
var foo = true, baz = 10;

if (foo) {
    var bar = 3;

    if (baz > bar) {
        console.log( baz );
    }

    // ...
}
```

下面这样的代码更容易重构：

```javascript
var foo = true, baz = 10;

if (foo) {
    var bar = 3;

    // ...
}

if (baz > bar) {
    console.log( baz );
}
```

在使用块级作用域的时候要小心这样的变化：

```javascript
var foo = true, baz = 10;

if (foo) {
    let bar = 3;

    if (baz > bar) { // <-- don't forget `bar` when moving!
        console.log( baz );
    }
}
```

附录B是块级作用域的另一种风格的代码（更显式），它可以提供更易于维护/重构的代码，让脚本有更高的鲁棒性。

### `const`

ES6引入的不仅是`let`，还有`const`。它也将创造一个块级作用域的变量，但是这些变量的值是固定的（常量）。任何试图改变它的值的行为都将会抛出一个错误。

```javascript
var foo = true;

if (foo) {
    var a = 2;
    const b = 3; // block-scoped to the containing `if`

    a = 3; // just fine!
    b = 4; // error!
}

console.log( a ); // 3
console.log( b ); // ReferenceError!
```

## 综述

函数是JavaScript中最常见的作用域单位。变量和函数在另外一个函数中声明，将会把外部封闭作用域中的变量和函数“遮蔽”住，这是一种很好的软件设计方法。
但是函数也并不是唯一的作用域单位，还存在着块级作用域。所谓块级作用域就是指，变量和函数可以属于任意的代码块（通常是一对`{..}`）之中。
从ES3开始，`try/catch`结构的`catch`块就有块级作用域了。
在ES6中，引入了`let`关键字（`var`关键字的亲戚），它允许声明属于任意代码块的变量。`if (..) { let a = 2; }`将会声明变量`a`，并且这个变量将会值存在于`if`语句的`{..}`块之中。
块级作用域并不应该完全取代`var`函数作用域，两种功能是可以并存的，开发者可以并且应该同时使用函数作用域和块级作用域技术，在不同的情况下使用更为适合的技术，这样才能创造出更易读，更易于维护的代码。

# 第四章：声明提升

变量通过声明的地点以及方式就能看出它会附加到不同等级的作用域中，现在，像是上述这样作用域的概念你应该非常熟悉了。不管是函数作用域还是块级作用域，它们都有这样一个相同规则：任何变量在哪个作用域声明，它就属于哪个作用域。
但是声明出现在作用域中的不同地点的时候，会有些微妙细节上的不同。我们将会在这里讲解这些细节是什么。

## 先有鸡还是先有蛋？

有一种想当然的想法，那就是JavaScript程序中的所有代码全都是一行接着一行自上往下顺序执行的。虽然这大致上是对的，但是这样的假设可能会引导你对你的程序产生错误的想法。
思考下面的代码：

```javascript
a = 2;

var a;

console.log( a );
```

你预测一下在`console.log(..)`语句之后会打印出什么？
很多开发者预测这里会是`undefined`，因为`var a`语句是在`a = 2`之后的，所以很自然就能假设这个变量被重新定义了，因此变量将会被赋值为默认值`undefined`。然而，这里将会输出`2`。
思考下面的片段：

```javascript
console.log( a );

var a = 2;
```

你可能会进行这样的假设，因为在之前的代码片段中展示了一种类似于自下而上的行为，那么在这个片段之中，也许也应该输出`2`。又可能会觉得在声明之前使用变量，这必须抛出一个`ReferenceError`错误。
不幸的是，这两个猜测都是错误的，这里将会输出`undefined`。
**这到底是怎么回事儿？**如此看来，这似乎是个鸡和蛋的问题，到底是先声明（蛋），还是先赋值（鸡）呢？

## 编译器又罢工了

要回答这个问题，我们需要回顾一下我们在第一章讨论的编译器的内容。引擎实际上总是会在解释代码之前把代码编译一遍，编译阶段会将会寻找作用域以及其中的声明们，并且把它们相互关联起来，这是第二章向我们展示的词法作用域的核心。
所以，对于这件事情最好的解释就是，所有函数和变量的声明，都会在你的任何代码运行之前被首先处理。
当你看到`var a = 2;`你可能会认为那是一个语句，但是JavaScript实际上会认为那是两个语句：`var a;`和`a = 2;`。第一句话，声明，将会在编译阶段被处理，第二句话，赋值，会在执行阶段的当前位置处理。
我们的第一个代码片段应该看作是这样的：

```javascript
var a;
```
```javascript
a = 2;

console.log( a );
```

其中第一部分是编译，第二部分是执行。
类似的，我们的第二个代码片段实际上处理为：

```javascript
var a;
```
```javascript
console.log( a );

a = 2;
```

所以，这其实是对于运行顺序的比喻，对于这个进程而言，变量和函数的声明都从它们所在的语句被搬运到了当前代码片段的顶部，这样的行为就被称作“声明提升”。
换句话来说，**是先有蛋（声明），然后才有鸡（赋值）**。
<p class="note">
只有声明本身才能提升，任何赋值或者是其他可执行逻辑都会保留在原处。假如声明提升重新排列了我们的可执行逻辑，这将造成非常严重的破坏。
</p>

```javascript
foo();

function foo() {
    console.log( a ); // undefined

    var a = 2;
}
```

函数`foo`的声明（在这种情况下，还包括了它作为实际函数的隐含值）被提升，所以它能够在第一行中被调用执行。
声明提升是对于**每个作用域**而言的，这也是必须要注意的事情。因此，虽然我们之前的片段进行了简化，那是因为它们被包含在了全局作用域内，我们可以继续检查`foo(..)`函数，在它的内部很显然，`var a`被提升到了`foo(..)`的顶部（很显然不是程序的顶部）。所以这个程序更应该是这样的：

```javascript
function foo() {
    var a;

    console.log( a ); // undefined

    a = 2;
}

foo();
```

就像我们之前看到的，函数声明被提升了，但是函数表达式则不会：

```javascript
foo(); // not ReferenceError, but TypeError!

var foo = function bar() {
    // ...
};
```

变量标识符`foo`被提升和连接到了这个程序的封闭作用域（全局），所以`foo()`并不会因为`ReferenceError`而失败。但是`foo`现在并没有值（因为它是个函数表达式为不是函数声明），所以`foo()`试图把`undefined`值当作函数来调用，这显然是个`TypeError`的非法操作。
此外，即使它是个具名的函数表达式，函数的名称标识符也不能用在封闭作用域内：

```javascript
foo(); // TypeError
bar(); // ReferenceError

var foo = function bar() {
    // ...
};
```

这个片段准确的解释（声明提升），应该是这样的：

```javascript
var foo;

foo(); // TypeError
bar(); // ReferenceError

foo = function() {
    var bar = ...self...
    // ...
}
```

## 函数优先

函数声明和变量声明都会被提升，但是它们也有些微妙的区别（能够在有着多重“重复”声明的代码中体现出来），那就是函数声明在前，然后才是变量声明。
例如：

```javascript
foo(); // 1

var foo;

function foo() {
    console.log( 1 );
}

foo = function() {
    console.log( 2 );
};
```

打印出了`1`，而不是`2`。这个片段对于引擎来说应该是这样的：

```javascript
function foo() {
    console.log( 1 );
}

foo(); // 1

foo = function() {
    console.log( 2 );
};
```

注意那个`var foo`是个重复（因此它被省略了）的声明，即使它是在`function foo()...`之前声明的，但是函数声明也会提升到普通变量之前。
正如多重/重复的`var`声明能够被有效的忽略一样，后面的函数声明也能够覆盖之前的函数声明。

```javascript
foo(); // 3

function foo() {
    console.log( 1 );
}

var foo = function() {
    console.log( 2 );
};

function foo() {
    console.log( 3 );
}
```

虽然这一切听起来和学术上的琐碎事情一样无趣，但也必须要注意，它强调了这样一个事实，即在同一个作用域内重复定义是一个非常糟糕的主意，这往往会导致混乱的结果。
通常出现在普通块内的函数声明将会提升至整个封闭作用域，而不会隐式的保留在条件语句中：

```javascript
foo(); // "b"

var a = true;
if (a) {
   function foo() { console.log( "a" ); }
}
else {
   function foo() { console.log( "b" ); }
}
```

但是，需要注意的是这种行为是不可靠的，又可能在未来的JavaScript版本中变化，所以尽可能的避免在块中声明函数。

## 综述

我们可以认为`var a = 2;`是一个语句，但是JavaScript引擎并不这么认为，它看到的是`var a;`以及`a = 2;`这样两个单独的语句，前者是编译阶段的任务，后者是运行阶段的任务。
无论在作用域内的所有声明在哪里，它们都将会在执行代码本身之前被处理。你可以将这种行为想象成声明（变量和函数）都被“搬”到了各自作用域的顶部，我们把这种行为称作“声明提升”。
声明本身都会被提升，但是赋值甚至是函数表达式的赋值都不会被提升。
一定要小心重复声明，尤其是将正常的`var`声明和函数声明混合——不要做这种危险的事情！

# 第五章：作用域闭包

我们希望你在阅读这一章的时候，你已经对作用域的工作原理已经有了扎实的理解。
接下来我们将会把注意力转移到语言的另一个部分：**闭包**，这部分非常重要，但是同时却像神话那样难以捉摸。但如果你认真跟随我们关于词法作用域的讨论至今，那么你理解闭包那就是水到渠成的事情。有个魔法师正在窗帘后面，现在我们即将见到他。不，他的名字不是Crockford^注^！
<p class="translator">
显而易见的，Douglas Crockford 又中枪了……
</p>

如果你现在对于词法作用域还是有点疑惑，那么现在回去复习第二章是个不错的选择，然后我们再继续。

## 启蒙

对于那些有过JavaScript经验，但是却并没有充分掌握闭包概念的人来说，理解闭包就像是必须要努力以及付出牺牲才能达到的涅槃状态。
我想起了几年前的我，那时候我对于JavaScript的掌握还不错，但是却并不知道什么是闭包。这提醒了我，这个语言还有着另外的一面，还有着比我已经掌握了的更强悍的能力，它就像是在嘲讽对此一无所知的我。我记得当时我去阅读一些早期框架的源代码，试图了解它是如何工作的。我还记得“模块模式”的某些模糊的东西第一次浮现在我的脑海的时候，我还清楚记得那时候“啊哈！”的那一刻。
那时候我还不明白，然后花了好几年才弄明白的东西，现在我希望把它传授给你的东西，那就是：**闭包在JavaScript中几乎无处不在，你只需要认出它然后接纳它就好了**。闭包并不是你必须学习的新语法或者是模式的特殊工具。不，闭包甚至不是你必须像卢克在原力中修炼那样必须要学会并掌握的武器。
闭包是依赖于词法作用域编写代码而产生的结果。它就那么发生了，你甚至不需要有意识的为了利用它们而创造闭包。闭包一直存在于你的代码之中，你也一直在使用着它。你缺少的只是适当的思维，来识别，接纳，最终有意识的使用闭包。
启蒙的时刻应该是这样的：**哦，闭包原来已经在我的代码中发生了，我现在终于看到它们了。**理解闭包就像是Neo第一次看到Matrix时候的感觉。

## 本质

好了，夸张的描述和无耻的电影引用就到此为止吧。
为了能理解闭包，你必须要知道闭包的一个简单粗暴的定义：

> 闭包就是当函数即便在它所在的词法作用域之外的地方运行的时候，也仍然能够记住和访问自己的词法作用域的结构。

我们还是用代码来说明上面的定义：
```javascript
function foo() {
    var a = 2;

    function bar() {
        console.log( a ); // 2
    }

    bar();
}

foo();
```

这段代码很像是我们之前讨论的嵌套作用域。函数`bar()`有权利访问封闭作用域外围的变量`a`，这是词法作用域查找变量的法则决定的（在这里，应该是RHS引用查找）。
这就是“闭包”？
唔，从技术上来说……大概是。但是从“你必须知道”这样的标准来看，它不太准确。我想最精确的解释是这样的，`bar()`通过词法作用域的查询法则引用了变量`a`，然而这些规则仅仅只是闭包的一部分（这很重要！）。
从纯粹的学术上的观点来看，在上面的代码片段中，函数`bar()`在函数`foo()`中有一个闭包（事实上，它还能访问其他的作用域，比如在这里的情况下还有全局作用域）。换句话来说，`bar()`封闭了`foo()`的作用域。为什么？因为`bar()`嵌套在`foo()`之中。简单直白。
但是，刚才对闭包的定义并不直观，我们也无法在那个代码片段中看到闭包。我们清楚的看到了词法作用域，但是闭包仍然隐藏在代码的阴影中。
让我们来思考下面这段代码，它将会照亮阴影中的闭包：

```javascript
function foo() {
    var a = 2;

    function bar() {
        console.log( a );
    }

    return bar;
}

var baz = foo();

baz(); // 2 -- Whoa, closure was just observed, man.
```

函数`bar()`能访问在它词法作用域内部的`foo()`作用域。但是，我们把函数`baz()`自身当作了一个**值**，在这里，我们`return`了函数对象`bar`的引用。
然后我们执行了`foo()`，将返回的值（在其内部的`bar()`函数）赋值给了变量`baz`，最后我们调用了`baz()`，这里仅仅是标识符引用有所不同，实际上我们调用了内部的函数`bar()`。
`bar()`当然执行了，但是在这样的情况下，它是在声明它的词法作用域之外执行的。
`foo()`函数执行之后， 一般情况下`foo()`的内部作用域将会全部消失，因为我们知道引擎有个叫做垃圾收集器的员工，它的作用就是当某个引用不会再被使用的时候，删除这个引用并释放内存。因此当`foo()`的上下文没有再被使用的时候，它将会被释放，这是很自然的想法。
但是，闭包的“魔法”并不会让这种事情发生。实际上，在内部作用域中它仍然被“使用”着。因此它不会被释放，那么是谁在使用它呢？**是函数`bar()`自己**。
 根据`bar()`是在哪里声明的，它在`foo()`内部的词法作用域中有一个闭包，这个闭包能够给函数`bar()`在之后的时间中保持这个作用域中的引用。
**`bar()`仍然拥有对那个作用域的引用，而这个引用就被称作闭包。**
所以，几毫秒之后，当我们的变量`baz`被调用（调用我们最开始标记为`bar`的内部函数）的时候，它当然能够访问在编写时就决定好了的词法作用域，所以它能够像我们期望的那样访问变量`a`。
函数能够在它编写时的词法作用域之外被正常的调用。**闭包**让函数能够继续拥有编写时就被定义号了的词法作用域的访问权。
当然，用各种各样的方式把函数当作是值来进行传递，然后在其他地方调用，这些都是非常明显的闭包的例子。

```javascript
function foo() {
    var a = 2;

    function baz() {
        console.log( a ); // 2
    }

    bar( baz );
}

function bar(fn) {
    fn(); // look ma, I saw closure!
}
```

我们把内部函数`baz`传递给了另一个`baz`，然后调用了那个内部函数（现在它被标记为`fn`），它在`foo()`内部作用域的闭包就可以通过访问`a`观察到。
函数的传递也可以是间接的。

```javascript
var fn;

function foo() {
    var a = 2;

    function baz() {
        console.log( a );
    }

    fn = baz; // assign `baz` to global variable
}

function bar() {
    fn(); // look ma, I saw closure!
}

foo();

bar(); // 2
```

无论你用什么样的方式将内部函数传输到它词法作用域之外，它都将会保持在它声明地点的作用域的引用，当我们执行这个函数的时候，闭包也将会运行。

## 现在我们能看到

上面的代码片段都是有点学术性的以及为了演示而故意构建的闭包。但是我保证，闭包绝不仅仅只是个有点酷的新玩具，我保证闭包早已经在你的代码中广泛的存在了。现在让我们直面真相吧。

```javascript
function wait(message) {

    setTimeout( function timer(){
        console.log( message );
    }, 1000 );

}

wait( "Hello, closure!" );
```

我们把内部函数（名字是`timer`）传给了`setTimeout(..)`。但是`timer`有一个作用域闭包在`wait(..)`内部，所以它将会保持变量`message`的引用。
在我们执行了`wait(..)`一千毫秒之后，它内部的作用域原本应该早已不复存在，但是内部函数`timer`仍然在那个作用域中保持着闭包。
在引擎的内部深处，内建的工具`setTimeout(..)`拥有一些参数的引用，可能被称作`fn`、`func`又或者是像是它们的其他什么东西。引擎调用了内部的`timer`函数，词法作用域的引用也仍然完好无损。
**闭包。**
或者，如果你喜欢用jQuery（或者是其他什么JS框架）：

```javascript
function setupBot(name,selector) {
    $( selector ).click( function activator(){
        console.log( "Activating: " + name );
    } );
}

setupBot( "Closure Bot 1", "#bot_1" );
setupBot( "Closure Bot 2", "#bot_2" );
```

我不知道你写的代码是什么样的，但是我经常写能够控制全球无人机军队的代码，所以这是完全现实的！
玩笑归玩笑，从本质上来说，无论何时何地，你把函数（能访问各自的词法作用域）作为第一类值，并将它们传输给周围，你可能就能看到这些函数行使了闭包。像是定时器，事件句柄，Ajax请求，跨窗口信息，web workers，或者是其他任何异步（或者是同步）任务，当你传输了一个回调函数，闭包就已经准备好了。

第三章介绍了IIFE模型，它也是个经常被提起的例子，因为它的闭包结构非常明显。但是我并不是十分同意这样的观点：

```javascript
var a = 2;

(function IIFE(){
    console.log( a );
})();
```

这个代码“工作了”，但是严格来说它并不是闭包。为什么？因为这个函数（这里它的名字是“IIFE”）并没有在它所属的词法作用域之外运行。它仍然是正常地被调用的，即它是在声明它的作用域中被调用的（这封闭/全局作用域中也保持着`a`）。`a`也是被正常的词法作用域查找查询到的，而并不是靠闭包。
所以闭包从技术上来说是在声明的时候发生的，但是却并不是可以严格观察到的，所以有人说那就像是森林中的一棵树倒掉了，但是却没有任何人听到。
虽然IIFE并不能作为闭包的示例，但是它确实创建了作用域，而且它是我们用来创建闭包作用域最常见的工具之一。所以即便IIFE本身并没有闭包，但它们确实与闭包有着非同一般的关系。

亲爱的读者，现在请你把这本书放下。我有一个任务给你。去打开一些你最近的JavaScript代码。寻找那些被你作为值的函数，并找找在那里的闭包们，你以前甚至可能不知道它。
我会等着你。
现在……你看到了！

## 循环+闭包

虽然这是个不起眼的`for`循环，但也是闭包最为常见最为典型的例子。

```javascript
for (var i=1; i<=5; i++) {
    setTimeout( function timer(){
        console.log( i );
    }, i*1000 );
}
```
<p class="note">
当你把函数放到循环内部的时候，质量检查器经常会抱怨，因为很多开发者都不能正确的理解闭包。我们在这里讲解了如何正确的使用闭包的力量，但是质量检查器经常并不能理解这其中的微妙之处，所以它就只能全部假定你并不能确实的知道你到底在干什么。
</p>

上面这个代码片段我们很简单的就能预测它接下来的行为，它将会每隔一秒依次打印出`1`、`2`，……`5`。
实际上，假如你运行了这个代码，你将会得到5个`6`，当然同样是每隔一秒。
**唔？**
首先，让我们解释一下这个`6`是从哪儿来的。这个循环的结束条件是`i`不满足`<=5`，因此当循环结束的时候，`i`是等于`6`的，所以这个输出是反映了循环结束之后的`i`的值。
如果你多看两眼的话，这其实是很明显的，延迟函数的回调都是在循环结束之后才运行的。事实上，设定好定时器之后，即便每次迭代中都是`setTimeout(..,0)`，但是所有的回调函数仍然会在循环结束之后才运行^注^，因此这里打印了6次。

<p class="translator">
用`setTimeout(..)`来解释闭包是非常经典的例子了，但是如果你不理解什么是`异步`的话，估计还是不太能理解这个例子，我在这里简单解释一下。
首先要说明的就是JavaScript单线程的，就是说任何时候只能同时运行一个任务。
然后是什么是`同步`和`异步`？都知道`setTimeout(..)`是延迟函数，假如说它是同步函数的话，那么`for`循环每次运行到这里都会等待，等待到延迟时间过去，然后继续下一次迭代，这就是同步的意思。
但是`setTimeout(..)`函数是异步的，所谓异步就是非同步。就是说这个函数内部的回调会在JavaScript主进程结束之后才会调用。到这个例子中，就是`for`循环会先运行完毕，然后等待延迟时间，到时间之后再运行回调；即便到了延迟时间主进程还没有运行完毕，那也还是要等主进程运行完毕了才会运行它内部的回调。所以，就算你的延迟时间是0ms，它也会在整个`for`循环结束之后才会运行。
</p>

但是，这里还有个更深层次的问题，为了让我们的代码按照在语义中暗示的那样运行，还少了什么东西？
我们正尝试让代码完成这样的行为，在每次循环迭代中“捕捉”`i`的副本。但是，根据作用域的工作方式，这所有的5个函数，虽然它们每次循环迭代都会单独定义，但是**它们都被封闭在同一个共享的全局作用域之中**，所以，其实这里只有一个`i`。
这样一来，所有的函数都共享了同一个`i`的引用。循环的结构导致我们把一些事情想的复杂了，其实不是这样的。不使用循环，仅仅是一个接着一个的声明这5个延迟回调，这种情况和使用循环来声明是一模一样的，没有任何不同。
好了，回到我们最为迫切的问题，我们到底少了什么东西？我们需要更多被闭包的作用域。特别的来说，我们在每一个循环迭代中都需要一个新的被闭包的作用域。
通过第三章，我们直到了IIFE通过声明函数然后立即执行它来创建作用域。
让我们试试看：

```javascript
for (var i=1; i<=5; i++) {
    (function(){
        setTimeout( function timer(){
            console.log( i );
        }, i*1000 );
    })();
}
```

它正确工作了吗？试试看，我会等着你的。
我来为你结束这个悬念，它也是不对的，但是为什么？我们现在已经确实拥有了更多的词法作用域，每次循环中都通过IIFE创建了作用域，然后把每个延迟回调封闭在了里面。
但是，仅仅有封闭作用域是不够的，因为作用域里面是空的。看仔细一点，我们的IIFE只是个空的作用域，它需要一些对我们有用的东西。
它还需要它自己的变量，当然我说的就是每次迭代的`i`的副本。

```javascript
for (var i=1; i<=5; i++) {
    (function(){
        var j = i;
        setTimeout( function timer(){
            console.log( j );
        }, j*1000 );
    })();
}
```

耶！它终于正确工作了！

<p class="translator">
我始终觉得在这一段中，作者讲述的逻辑有点奇怪。
上面作者提到，这个循环+延迟之所以无法正常工作，其原因就是因为它们引用的`i`其实是同一个，所以最后打印出来的值都是一样的。但是接下来他说道：“我们还需要更多被闭包了的作用域。”然后才提到闭包中保存`i`的值。我觉得这有点本末倒置啊，正常的逻辑难道不应该是——
因为我们引用了同一个`i`，假如我们要正常工作，那么就必须要引用不同的`i`，如何在循环之中为不同的`i`保存其副本呢，那么我们就需要闭包。
这样的逻辑顺序才是正常的吧。
</p>

有些人更喜欢它的变体：

```javascript
for (var i=1; i<=5; i++) {
    (function(j){
        setTimeout( function timer(){
            console.log( j );
        }, j*1000 );
    })( i );
}
```

当然，因为这些IIFEs都是函数，我们能够把`i`当作参数传进去，如果我们愿意，在函数内部我们可以把它当作`j`，或者还是叫做`i`，这都没有关系。不管怎么样，代码正常工作了。
利用IIFE在每个迭代中创建新的作用域，它们能够在每次迭代中让延迟函数回调封闭在新作用域中，并且在那之中还有个正确的迭代值供它们访问。
问题解决了！

### 再谈块级作用域

仔细看看我们对于前面的解决方案的分析，我们使用了IIFE来为每次迭代创建作用域，换句话说，我们确实需要每次迭代的**块级作用域**。第三章给我们展示了`let`的声明，它能够劫持一个块，然后声明一个属于当前块的变量。
**上面那个解决方案的本质就是把块封闭起来，让它变成作用域。**所以，下面这个牛逼的代码也能“正常工作”:

```javascript
for (var i=1; i<=5; i++) {
    let j = i; // yay, block-scope for closure!
    setTimeout( function timer(){
        console.log( j );
    }, j*1000 );
}
```

但，这也不是全部！（用我最棒的Bob Barker嗓音）当你用`let`在`for`循环头部进行声明的时候，这其实还包含了一个特殊的行为。对于这个循环而言，这个变量将不会仅仅声明一次，而是**每次迭代都会重新声明**。这种行为是非常有帮助的，它将会使用上一次迭代结束的值来完成后续迭代的初始化。

```javascript
for (let i=1; i<=5; i++) {
    setTimeout( function timer(){
        console.log( i );
    }, i*1000 );
}
```

这实在是太酷了。块级作用域和闭包携手并进，解决了一个世界级的问题。我不知道你是怎么想的，但这对于我这个JavaScripter来说，让我觉得非常高兴。

## 模块

这里还有些其他的代码形式使用了闭包的力量，但是它们都不像回调那样浮于表面。让我们来看看它们之中最强大的模式：模块。

```javascript
function foo() {
    var something = "cool";
    var another = [1, 2, 3];

    function doSomething() {
        console.log( something );
    }

    function doAnother() {
        console.log( another.join( " ! " ) );
    }
}
```

这些代码在这里了，这里并没有看到有闭包。我们只是有一些私有的数据变量`something`和`another`，另外还有一对函数`doSomething()`和`doAnother()`，它们都有覆盖在`foo()`内部作用域的词法作用域（因此它们都是闭包！）。

现在再看看这些代码：

```javascript
function CoolModule() {
    var something = "cool";
    var another = [1, 2, 3];

    function doSomething() {
        console.log( something );
    }

    function doAnother() {
        console.log( another.join( " ! " ) );
    }

    return {
        doSomething: doSomething,
        doAnother: doAnother
    };
}

var foo = CoolModule();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

这就是我们在JavaScript中称作**模块**的模式。创建模块最常见的方法被称做“揭示模块”，这里我们展示的是它的一个变种。
我们现在来解释一下这段代码发生了什么。
首先，`CoolModule()`只是一个函数，但它必须被调用才能成为一个被创建的模块实例。没有外部函数的执行，内部作用域的创建和闭包都不会发生。
第二，`CoolModule()`函数返回了一个对象，这个对象是通过对象字面量语法`{ key: value, ... }`标记的。我们返回的这个对象拥有指向我们内部函数的引用，但是没有指向我们内部数据变量的引用。我们可以将它们隐藏起来，保证它们的私有性。很明显的，这个返回的对象，其本质就是**我们模块的公共API**。
这个返回的对象最终被赋值给外部变量`foo`，然后我们可以在API中访问那些属性方法，比如`foo.doSomething()`。

<p class="note">
并不是一定要从模块中返回一个实际的对象（字面量）。我们也可以仅仅直接返回一个内部函数。jQuery就是一个很好地例子。`jQuery`和`$`标识符是jQuery“模块”的公有API，但是它们本身只是一个函数（函数本身可以拥有属性，因为所有的函数都是对象）。
</p>

`doSomething()`和`doAnother()`函数拥有模块“实例”内部作用域的闭包（通过实际调用`CoolModule()`得到的）。通过返回对象的属性引用，我们可以将这些函数传送到词法作用域外部，这时我们就建立好了可以观察和行使闭包的条件。
更简单地说，实行模块模式有两个“必要条件”：
1. 必须有一个外部的封闭函数，而且它必须至少被调用一次（每次都会创建一个新的模块实例）。
2. 封闭函数必须至少返回一个内部函数，这样这个内部函数才拥有私有作用域的闭包，并且可以访问或修改这个私有状态。

一个仅带有一个函数属性的对象不是真正的模块。从可观测的角度来说，一个从函数调用中返回的对象，仅带有数据属性而没有闭包的函数，也不是真正的模块。
上面的代码片段展示了一个称为`CoolModule()`独立的模块创建器，它可以被调用任意次，每次创建一个新的模块实例。当你只想要一个实例的时候，只需要对这种模式做一个小小的变化，某种“单例”：

```javascript
var foo = (function CoolModule() {
    var something = "cool";
    var another = [1, 2, 3];

    function doSomething() {
        console.log( something );
    }

    function doAnother() {
        console.log( another.join( " ! " ) );
    }

    return {
        doSomething: doSomething,
        doAnother: doAnother
    };
})();

foo.doSomething(); // cool
foo.doAnother(); // 1 ! 2 ! 3
```

在这里，我们将我们的模块函数转变成了IIFE，然后我们立即调用了它，最后把它的返回值直接赋值给了我们的单个模块实例的标识符`foo`。

模块都是函数，所以它们能够接受参数：

```javascript
function CoolModule(id) {
    function identify() {
        console.log( id );
    }

    return {
        identify: identify
    };
}

var foo1 = CoolModule( "foo 1" );
var foo2 = CoolModule( "foo 2" );

foo1.identify(); // "foo 1"
foo2.identify(); // "foo 2"
```

对于模块模式而言，还有另外一种虽然细微但也非常有用的变体，那就是给你返回的公共API命名：

```javascript
var foo = (function CoolModule(id) {
    function change() {
        // modifying the public API
        publicAPI.identify = identify2;
    }

    function identify1() {
        console.log( id );
    }

    function identify2() {
        console.log( id.toUpperCase() );
    }

    var publicAPI = {
        change: change,
        identify: identify1
    };

    return publicAPI;
})( "foo module" );

foo.identify(); // foo module
foo.change();
foo.identify(); // FOO MODULE
```

因为公共API对象保持着模块实例的内部引用，所以你能够**从内部**修改模块实例，包括增加删除方法、属性以及改变值。

### 现代模块

不同的模块依靠着不同的加载器/管理器，从本质上来说它们都是将模块定义包装进了一个友好的API之中。为了展示这个概念，与其讲解一个特定的库，不如让我提供一个非常简单的概念证明：

```javascript
var MyModules = (function Manager() {
    var modules = {};

    function define(name, deps, impl) {
        for (var i=0; i<deps.length; i++) {
            deps[i] = modules[deps[i]];
        }
        modules[name] = impl.apply( impl, deps );
    }

    function get(name) {
        return modules[name];
    }

    return {
        define: define,
        get: get
    };
})();
```

这段代码的关键就是`modules[name] = impl.apply(impl, deps)`。这里是把调用的定义包装函数作为了一个模块（传入所有依赖），并将返回值，也就是模块的API，储存到一个用名称追踪的内部模块列表中。

我可能会用它这样定义一个模块：

```javascript
MyModules.define( "bar", [], function(){
    function hello(who) {
        return "Let me introduce: " + who;
    }

    return {
        hello: hello
    };
} );

MyModules.define( "foo", ["bar"], function(bar){
    var hungry = "hippo";

    function awesome() {
        console.log( bar.hello( hungry ).toUpperCase() );
    }

    return {
        awesome: awesome
    };
} );

var bar = MyModules.get( "bar" );
var foo = MyModules.get( "foo" );

console.log(
    bar.hello( "hippo" )
); // Let me introduce: hippo

foo.awesome(); // LET ME INTRODUCE: HIPPO
```

`foo`和`bar`模块都是是用函数返回公共API来定义的，`foo`甚至接受了`bar`的一个实例来作为依赖的参数，所以能够使用它。
为了完全理解闭包的力量，花些时间来检查这些代码片段，看看闭包都给我们带来了什么样的好处。关键之处在于，对于模块管理器来说真的没有什么特殊的“魔法”。它们只是满足了我在上面列出的模块模式的两个特性：调用一个函数定义包装器，并将它的返回值作为这个模块的API保存下来。
换句话说，模块就是模块，即便你在它们上面放了一个友好的包装工具。

### 未来的模块

ES6增加了模块的概念作为第一类语法支持。当我们通过模块系统加载模块的时候，ES6将单个文件视作是单独的模块。每个模块都能导入其他模块或者是特定的API成员，当然同时也能导出它们自己的公共API成员。

<p class="note">
基于函数的模块不能被静态识别（编译器知道的某种东西），所以它们的API语义直到运行时才会被考虑。也就是，你实际上可以在运行时期间修改模块的API（参见之前`publicAPI`的讨论）。
</p>

相比之下，ES6模块API是静态的（这些API不会在运行时改变）。因为编译器知道它，它可以（也确实是这么做的！）在（文件加载和）编译期间检查一个指向被导入模块的成员的引用是否实际存在。如果API引用不存在，编译器就会在编译时抛出一个“早期”错误，而不是等待传统的动态运行时的结果（和错误，如果有的话）。
ES6模块**没有**“内联”格式，它们必须被定义在独立的文件中（每个模块一个）。浏览器/引擎拥有一个默认的“模块加载器”（它是可以被覆盖的，但是这超出了我们在此讨论的范围），它在模块被导入时同步地加载模块文件。
考虑这段代码：
**bar.js**

```javascript
function hello(who) {
    return "Let me introduce: " + who;
}

export hello;
```

**foo.js**

```javascript
// import only `hello()` from the "bar" module
import hello from "bar";

var hungry = "hippo";

function awesome() {
    console.log(
        hello( hungry ).toUpperCase()
    );
}

export awesome;
```

```javascript
// import the entire "foo" and "bar" modules
module foo from "foo";
module bar from "bar";

console.log(
    bar.hello( "rhino" )
); // Let me introduce: rhino

foo.awesome(); // LET ME INTRODUCE: HIPPO
```

<p class="note">
使用前两个代码片段中的内容分别创建两个独立的文件**“foo.js”**和**“bar.js”**。然后，你的程序将加载/导入这些模块来使用它们，就像第三个片段那样。
</p>

`import`将会在当前的作用域中导入一个模块的API的一个或多个成员，每个成员都将会绑定到一个变量（这个例子中是`hello`）。`module`将整个模块的API导入到一个被绑定的变量（这个例子中是`foo`，`bar`）。`export`为当前模块的公有API导出一个标识符（变量，函数）。在一个模块的定义中，这些操作符可以根据需要使用任意多次。
在模块文件内部的内容被视为封闭的作用域闭包中，就像之前使用函数闭包的模块那样。

## 综述

闭包就像在JavaScript内部被隔离开的魔法世界，只有少数勇敢的灵魂才能到达。但是它实际上只是一个标准的，而且几乎是非常明显的事实——我们如何在作为值的函数，而且可以被随意传递的词法作用域环境中编写代码。
**闭包就是当一个函数即使是在它的词法作用域之外被调用时，也可以记住并访问它的词法作用域。**
如果我们不能小心地识别它们和它们的工作方式，闭包可能会绊住我们，例如在循环中。但它们也是一种极其强大的工具，比如各种形式的模块。
模块要求两个关键性质：
1. 一个被调用的外部包装函数，来创建封闭作用域。
2. 这个包装函数的返回值必须包含至少一个内部函数的引用，这个函数才拥有包装函数内部作用域的闭包。

现在我们看到了闭包在我们的代码中无处不在，而且我们有能力识别它们，并为了有意识地利用它们！

# 附录A：动态作用域

在第二章，我们谈到了“动态作用于”，拿它和JavaScript使用的“词法作用域”模型（实际上，大多数语言都在使用这个模型）做了简单的对比。
我们将简单分析以及对比一下动态作用域。但是更重要的是，动态作用域实际上更接近于JavaScript中的另一种机制（`this`），我们将会在本系列的《this和对象原型》中进行介绍。
正如我们在第二章看到的，词法作用域是引擎如何以及在哪里查找变量的一套规则。词法作用域的主要特点是，它在你编写代码的时候就已经被定义好了（假设你没有使用`eval()`或者`with`）。
动态作用域这个名字似乎就是在暗示着，这是个可以在运行时动态决定作用域的模型。事实上也正是如此，让我们通过代码来说明：

```javascript
function foo() {
    console.log( a ); // 2
}

function bar() {
    var a = 3;
    foo();
}

var a = 2;

bar();
```

在函数`foo()`中，词法作用域将会使用RHS查找把变量`a`解析为全局变量，所以最后将会输出`2`。
相比之下，动态作用域从来不关心函数作用域是在哪里以及用什么方式声明的，它更关心它是在哪里被调用的。换句话说，作用域链是基于调用栈的，而不是嵌套的作用域。
所以，如果JavaScript有动态作用域的话，当`foo()`执行的时候，理论上这段代码最后将会输出`3`。

```javascript
function foo() {
    console.log( a ); // 3  (not 2!)
}

function bar() {
    var a = 3;
    foo();
}

var a = 2;

bar();
```

为什么会这样？因为当`foo()`无法解析变量`a`的引用的时候，它将不会沿着嵌套（词法）作用域查找，而会从`foo()`被调用的地方沿着调用栈向上查找。因为`foo()`是在`bar()`内部调用的，所以它会检查`bar()`作用域内部的变量，然后找到了`a`的值——`3`。
现在你是不是觉得很奇怪？
但是这是因为你已经习惯了词法作用域的思考方式，所以动态作用域似乎有点外国人的感觉。假如你以前只写过动态作用域语言的代码，你会觉得这其实挺自然的，相对的，你可能会觉得词法作用域是什么鬼。
需要明确的是，**JavaScript没有动态作用域**，它毋庸置疑使用的是词法作用域模型。但是`this`的机制和动态作用域有点相似。
它们之间关键的区别是：**词法作用域是在编写代码时就已经定义好了，而动态作用域（以及`this`！）是在运行的时候才会决定**。词法作用域关心函数是在哪里被声明的，而动态作用域关心函数是在哪里被调用的。
最后：`this`关心的是**函数是怎样被调用的**，这显示出`this`机制和动态作用域到底有多么相近的关系。为了挖掘更多的信息，请阅读《this和对象原型》。

# 附录B：Polyfilling块级作用域

在第三章我们探讨了块级作用域，我们看到了`with`和`catch`这两个块级作用域的小小例子，而它们俩至少从ES3起就已经存在了。
但是ES6引进了`let`，才最终完整的实现了块级作用域，我们也终于能在代码中不受约束的使用块级作用域了。这实在是太令人兴奋了，无论是从功能上还是从代码风格上来说，都应该启用块级作用域。
但是假如我们想在ES6之前的环境中使用块级作用域，那该怎么办？
想想下面的代码：

```javascript
{
    let a = 2;
    console.log( a ); // 2
}

console.log( a ); // ReferenceError
```

它们能在ES6环境中工作的很好，但是在ES6之前的环境应该怎么办？答案是`catch`。

```javascript
try{throw 2}catch(a){
    console.log( a ); // 2
}

console.log( a ); // ReferenceError
```

这代码是在是太丑了……我们能看到，这里是在强制抛出一个错误，但是这个抛出的“错误”仅仅是一个值`2`，然后变量声明被`catch(a)`块接受了。
没错，`catch`块是用块级作用域，这意味着可以用它来对ES6之前环境的块级作用域做polyfill。
“但是……”，你说：“……没人愿意写那样丑陋的代码啊！”确实如此，没人（部分）愿意写这由CoffeeScript编译器输出的代码。但这不是重点。
重点是有工具可以将ES6代码转换编译到ES6之前的环境。你能够在代码中使用块级作用域，并且从它的功能中收益，由构建工具来做代码展开的工作。
使用代码转换编译工具把ES6代码生产成ES5兼容的代码，以度过这段过渡期。这绝对是所有人（嘛，至少是绝大部分吧）的选择。

## Traceur

Google维护着一个叫做Traceur的项目，这个项目的任务就是将ES6的特性转换编译到先ES6（主要是ES5，但不是全部）。TC39委员会依靠这个工具（和其他人）来测试他们指定功能的语义。
Traceur把我们的代码片段变成了什么？我想你已经猜到了。

```javascript
{
    try {
        throw undefined;
    } catch (a) {
        a = 2;
        console.log( a );
    }
}

console.log( a );
```

所以，使用这样的工具，无论我们的目标是不是ES6，我们都可以开始利用块级作用域了，因为`try/catch`从ES3就已经存在了。

## 隐式的与显式的块级作用域

在第三章中，我们发现了当我们引入块级作用域的时候，有一些潜在的陷阱可能会影响代码的可维护性和可重构性。有没有其他的方法来减少这样的影响呢？
我们来考虑`let`的另外一种变形，这被称作`let`块或者是`let`语句（对比之前的`let`声明形式）。

```javascript
let (a = 2) {
    console.log( a ); // 2
}

console.log( a ); // ReferenceError
```

相比于隐式的劫持已经存在的块，`let`语句直接显式地创建了块，并为它绑定了作用域。这么做不仅使得块显得更加突出，而且也会让代码在重构时有更强的鲁棒性，通过这样的语法，强制将所有的声明都放在块的顶部，这样产生的代码在某种意义上显得非常干净，也能够更容易的看出哪个块是属于它的作用域。
作为一种模式，它反映出了大部分人在使用函数作用域时候采用的方法，即手动地将所有`var`声明移动/提升到函数的顶部。`let`语句有意地将它们放在块顶部，而且如果你没有通篇到处使用`let`声明，那么你的块级作用域声明就会在某种程度上更易于识别和维护。

但是，这还有一个问题，ES6还不包括`let`语句的形式。而且，连官方的Traceur编译器也不接受这种形式的代码。
我们有两个选择，可以使用ES6有效的语法，再人为的加上点代码规范：

```javascript
/*let*/ { let a = 2;
    console.log( a );
}

console.log( a ); // ReferenceError
```

但是，工具的存在就是为了解决我们的问题，因此另外一个选择就是，依旧编写显式的`let`语句块，然后让工具合法的将它们转换成可以工作的代码。
所以，我搞了个叫做`let-er`的工具来解决眼前的问题。let-er是个构建步骤的代码转换编译器，但是它唯一的任务就是找到let语句然后转换编译它们。它会远离你代码中包括`let`声明的其它部分，你可以放心的使用let-er作为你ES6转换编译的第一步，然后在必要的时候通过类似Traceur的工具来继续转换你的代码。
此外，let-er还有个配置标志`--es6`，打开它（默认关闭）的时候将会改变生成的代码种类。与以`try/catch`为核心的ES3级代码不同的是，let-er将会让我们的代码片段完全兼容ES6：

```javascript
{
    let a = 2;
    console.log( a );
}

console.log( a ); // ReferenceError
```

所以，你可以立即开始使用 let-er了，而且可以面向所有的前ES6环境，当你仅关心ES6时，你可以加入配置标志，那你就只需要面向ES6了。
而且最重要的是，**你可以使用更好的和更明确的let语句形式**，即便它（还）不是任何ES官方版本的一部分。

## 性能

最后，我想针对`try/catch`的性能问题再快速的补充几点，并说明/或解决这个问题：“为什么不使用一个IIFE来创建作用域？”
首先，`try/catch`的性能确实是慢一些，但是没有任何合理的假设表明它必须是这样，或者它总是这样。因为TC39认可的官方ES6转译器使用`try/catch`，Traceur团队也已经让Chrome去改进`try/catch`的性能了，而且它们有很明显的动力这样做。
第二，IIFE和`try/catch`不是一个公平的“苹果对苹果”的比较，因为一个包装着任意代码的函数将会改变这段代码的含义，尤其是内部的`this`，`return`，`break`，和`continue`。IIFE不是合适的具有通用性的替代品，它只能在特定的情况下手动使用。
那么最后，真正的问题就变成了：你是否想要使用块级作用域？如果是，这些工具给你提供了这些选择。如果不，那就在你的代码中继续使用var吧！

# 附录C：词法this

虽然整本书并没有对`this`的机制进行任何细节上的讲解，但是ES6有一个功能让`this`和词法作用域有了非常重要的联系，我们将在这里快速的讲解一番、
ES6增加了一个特殊的函数声明形式，那就是“箭头函数”，它是这样的：

```javascript
var foo = a => {
    console.log( a );
};

foo( 2 ); // 2
```

这个胖胖的箭头符号，是繁琐冗长的关键字`function`的缩写。
但是在箭头函数上发生的很多事情要更为重要，比你在键盘上少敲几个字母要重要得多。

简单的来说，这段代码有个问题：

```javascript
var obj = {
    id: "awesome",
    cool: function coolFn() {
        console.log( this.id );
    }
};

var id = "not awesome";

obj.cool(); // awesome

setTimeout( obj.cool, 100 ); // not awesome
```

问题就在于，`cool()`函数的`this`绑定丢失了。有很多方法可以解决这个问题，但是有一个经常重复的解决方案就是`var self = this;`。
看起来是这样：

```javascript
var obj = {
    count: 0,
    cool: function coolFn() {
        var self = this;

        if (self.count < 1) {
            setTimeout( function timer(){
                self.count++;
                console.log( "awesome?" );
            }, 100 );
        }
    }
};

obj.cool(); // awesome?
```

简单的来说，`var self = this`的“解决方案”免除了正确理解以及妥善使用`this`绑定的问题，取而代之的是让问题回落到我们更熟悉的地方：词法作用域。`self`成为了一个标识符，而它当然能通过词法作用域和闭包来解决，我们也不必关心`this`绑定到底发生了什么。
大家都不喜欢写冗长的东西，尤其是当他们需要一遍又一遍的这么做的时候。因此ES6的其中一个动机就是为了能减轻这些场景带来的负担，而事实上，这个场景就是其中之一。
ES6的解决方案，箭头函数，引入了一个被称做“词法this”的行为：

```javascript
var obj = {
    count: 0,
    cool: function coolFn() {
        if (this.count < 1) {
            setTimeout( () => { // arrow-function ftw?
                this.count++;
                console.log( "awesome?" );
            }, 100 );
        }
    }
};

obj.cool(); // awesome?
```

简单的解释就是，箭头函数并不会像普通函数那样进行`this`绑定，它们抛弃了所有正常的`this`绑定规则，而将会让`this`的值直接等于当前词法封闭作用域内的`this`，不管这个值是什么。
所以，在刚才那个片段中，箭头函数并不是没有按照某种不可预知的方式绑定，而是“继承”了函数`cool()`的`this`绑定。
虽然这让代码变得更短了，但是在我看来，箭头函数的功能真的只是将开发者们大范围的错误编辑成了语言语法，它混淆了“this绑定”和“词法作用域”的规则。
换句话来说，为什么要使用`this`风格的代码形式以至于让代码变得麻烦和冗长，为什么不把它从词法引用中剔除掉？在代码片段中使用一种代码风格看起来才更自然，而不是将它们混合起来。

<p class="note">
对箭头函数的另一个批评就是，它是匿名的。看看第三章为什么具名函数比匿名函数理想。
</p>

在我看来，这个“问题”的更恰当的解决方法是，正确地使用并接受this机制。

```javascript
var obj = {
    count: 0,
    cool: function coolFn() {
        if (this.count < 1) {
            setTimeout( function timer(){
                this.count++; // `this` is safe because of `bind(..)`
                console.log( "more awesome" );
            }.bind( this ), 100 ); // look, `bind()`!
        }
    }
};

obj.cool(); // more awesome
```

不管你是偏好箭头函数的词法this行为，还是偏好经得起考验的`bind()`，重要的是要注意箭头函数可**不**仅仅是可以少打一些“function”。
它们拥有一种我们应当学习并理解的，**有意的行为上的不同**，而且如果我们这样选择，就可以利用它们。
现在我们完全理解了词法作用域（和闭包！），理解词法this当然是小菜一碟！