---
title: 博客架构介绍
create: 2022/05/15
description: 如你所见，这又是篇介绍我怎么折腾博客架构的文章。
---

# 概述

博客里文章没几篇，但是博客架构被我前前后后折腾四五次了~~捂脸~~。
现在这个版本是目前为止觉得比较合乎我自己设想的版本，这篇文章主要是记录一下这次新架构被我折腾成啥样了，一方面也是好久没写~~懒狗~~文章了，来水一篇博文。

# 名词说明

|   名称   | 说明                                                                                 |
| :------: | :----------------------------------------------------------------------------------- |
|   模板   | 网页模板，即生成 HTML 文件的部分内容。                                               |
|   脚本   | JavaScript 脚本，在这里是指网页使用`script`标签引用的代码。                          |
|   样式   | CSS 代码，在这里是指网页使用`link`标签且包含属性`type="text/css"`引用的代码。        |
| Monorepo | 在单个代码库里包含了许多项目的代码，这些项目虽然有可能相关，但通常在逻辑上是独立的。 |

# 版本简述

## 1.0

在最早的博客架构中，采用的是最传统的结构，即——所有内容都是分开写的，依靠着各种很弱的“约定俗成”来达成不同资源的引用和共享，虽然这种形式是可以完成目的的，但是写起来非常烦人，各种“约定俗成”的规则都能单独记一个文件，每次我要改动某个配置，都要先看看这个规则文件，然后看有没有改错某个路径，非常的不方便。当时的模板采用的是 [PUG](https://pugjs.org)，样式是 [Stylus](https://stylus-lang.com/)，Markdown 解析器是个人修改的 [marked](https://github.com/xiaoboost/blog/blob/1.0/lib/marked.js)。
这个架构没多久就被我抛弃了，然后便是之后的*2.0*版本。

## 2.0

这个版本我采用了当时比较流行的 Vue 框架，借助通用的 Webpack 编译工具实现了各种静态资源的随意引用，网站也改为了*单页应用*的形式。但是编译虽然是方便了，但是最终的效果没能达成当初设定的要求，主要问题在单页应用上，它主要有两个问题——

- 产物太大了
- 首屏效果不好

这两点都很好理解，单页应用的构建流程里，它会把 Vue 等库全部打包进产物中，并且在首屏它是会先实例化 Vue，然后再去渲染，是完不成首屏直出的效果的。Markdown 解析器沿用的 1.0 版本，这个解析器的优势是小巧，但是也有个很严重的问题，就是太麻烦了。我想要加个数学公式的组件，想要加个复杂的显示效果，都必须要修改解析器的解析流程来实现，非常的麻烦。并且，虽然 Vue 是单文件组件，但是这只是把代码放在了一个文件里，他们之间并没有实现彻底的共享变量，尤其是对于我希望能在模板和样式之间共享变量时候，就非常纠结。

为了改进以上这几个问题，我又进行了次重构，这就是后来的*3.0*版本。

## 3.0

这个版本为了解决共享变量的问题，决定采用全`TypeScript`来写，模板部分更换为 [React](https://reactjs.org/)，样式则采用了 [JSS](https://cssinjs.org/)。这两者的共同优势就是，因为都是 JavaScript 语言的延申，所有可以非常方便的在之间共享变量，就和引用普通的 JS 模块那样。另外，为了保证首屏效果， React 和 JSS 并不会被打包到运行时的代码中，所有内容都会在本地编译中生成好。静态网页使用 React 的 SSR 功能输出，样式文件则使用 JSS 来输出编译好的代码。
Markdown 编译器也更换成了 [MDX](https://www.mdxjs.com)，它的优势就在于，允许在 Markdown 中引用 React 组件，于是添加新组件的时候，可以直接在`.md`文件中使用`import`语句来引用，并不需要去变更解析器的解析流程了。
这样下来，就实现了*模板*、_脚本_、_样式_、*文章*这四者之间模块和变量的共享。

对于编译流程，因为这套流程改动太大，于是干脆去掉了 Webpack，手动编写编译流程。为了方便管理，将不同的模板、组件都拆分开，使用`Monorepo`来管理这么多包。

到此为止，似乎看起来还挺好的，其实不然，这里还是有几个问题：

1. JSS 中引用了另一个样式文件（`@import`形式），若是这个样式文件里还有静态资源（比如字体），此时是无法识别的，因为这个 JSS 本质上是脚本，解析器无法递归的去解析里面的样式文件具体是什么。
2. 采用了 Monorepo 之后，每个模板/组件都被迫单独编译，调试的时候实在是痛苦，因为我需要开两个线程，一个是主构建流程，还有一个是当前正在修改/调试的组件库，实在是麻烦。
3. 在构建过程中，我们需要把所有组件的静态资源都全部打包到一起吗？比如 katex 数学公式库，这个库的样式和字体的体积特别大，如果打包到整体的样式文件中，每次打开网站都要一起加载，这实在是不怎么*优雅*。

## 当前版本

前言已经说的太多了，终于说到了现在的*4.0*版本了。没错，这个版本就是为了解决上述问题才诞生的，基本上而言，这个版本我觉得拿来做日常使用已经没有什么大问题了，剩下还有些诸如构建不够快，错误提示不够明显之类的事情，都是不需要变更架构的小问题。实际上，改了这么多版本，其核心要点总结其实是：

1. 变量共享
2. 自定义组件
3. 代码分割

# 详细说明

## 以 Esbuild 为核心的构建流程

## JSS 加载器

## Script 加载器

## Post 加载器

## Monorepo 依赖隔离

# 还有哪里不够完善

# 总结
